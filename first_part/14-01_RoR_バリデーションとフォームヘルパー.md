# Ruby on Rails: バリデーションとフォームヘルパー

## 目次
+ [バリデーション(validation:検証)とは](#バリデーションvalidation検証とは)
  + [例外とは](#例外とは)
  + [手動でバリデーションをトリガしてみる](#手動でバリデーションをトリガしてみる)
  + [バリデーションを設定してみる](#バリデーションを設定してみる)
  + [バリデーション実行時の動作を確認してみる](#バリデーション実行時の動作を確認してみる)
  + [バリデーションエラーの詳細を見る](#バリデーションエラーの詳細を見る)
  + [`form_with`ヘルパーとは](#form_withヘルパーとは)
  + [独自のバリデーションを作成しよう](#独自のバリデーションを作成しよう)

<br>

---

## バリデーション(validation:検証)とは  
ActiveRecordの**バリデーション**（検証）機能について説明します。  

**バリデーション**は、オブジェクトを**データベース**に保存する前に、データの正しさを確認する仕組みです。たとえば、入力された**文字**や**型**が適切かをチェックできます。**モデル**単位で設定可能です。  

オブジェクトを変更する以下のメソッド実行時に自動で**バリデーション**が行われ、エラーがある場合は保存されません。

| メソッド | 説明 | バリデーション失敗時の挙動 |
|---|---|---|
| `create` | 新しいレコードをデータベースに保存します。 | バリデーションが失敗した場合、`false`を返す。 |
| `create!` | 新しいレコードをデータベースに保存します。 | バリデーションに失敗した場合、`ActiveRecord::RecordInvalid`例外を発生させる。 |
| `save` | レコードの変更をデータベースに保存します。 | バリデーションが失敗した場合、`false`を返す。 |
| `save!` | レコードの変更をデータベースに保存します。 | バリデーションに失敗した場合、`ActiveRecord::RecordInvalid`例外を発生させる。 |
| `update` | 既存のレコードの属性を変更してデータベースに保存します。 | バリデーションが失敗した場合、`false`を返す。 |
| `update!` | 既存のレコードの属性を変更してデータベースに保存します。 | バリデーションに失敗した場合、`ActiveRecord::RecordInvalid`例外を発生させる。 |

---

### 例外とは  
プログラムを実行しているときに**問題**が発生することを**例外**と言います。

- プログラムが予期しない状況に遭遇したときに発生します。たとえば：
  - データが登録できない
  - **ゼロでの除算**
  - **ファイルが見つからない** など
- 例外は**エラー**の一種で、特定の状況で発生します。通常、ユーザーがプログラムを実行する際に発生します。

**例外**が発生すると、プログラムの通常の流れが止まり、例外を処理するための特別な処理が行われます。  
これが**例外処理**です。**例外処理**は、発生した例外を**捕捉（キャッチ）**して、適切な対処を行う仕組みです。

この仕組みを使うことで、プログラムがクラッシュすることなく、エラーに対処し続けることができます。

**例外処理**は通常、次のように書きます。

```rb
begin
  # 例外が発生する可能性のあるコード
rescue SomeException => e
  # 例外が発生したときの処理
  puts "エラーが発生しました: #{e.message}"
end
```

`begin`から`rescue`までの間に**例外**が発生した場合、その例外を**捕捉**し、適切な処理を行います。例外が発生しない場合、`rescue`部分は実行されません。**例外**を捕捉することで、プログラムが安定して動作し、予期しないエラーに対処できます。

---

### 手動でバリデーションをトリガしてみる  
`valid?`メソッドを使うと、手動で**バリデーション**を実行できます。

オブジェクトに対して`valid?`メソッドを使うと、そのオブジェクトに設定された**バリデーション**がチェックされます。もしそのオブジェクトに**エラー**がなければ「`true`」を返し、エラーがあれば「`false`」を返します。

また、`invalid?`メソッドもあり、これは`valid?`の逆の動きです。もしオブジェクトにエラーがあれば「`true`」、エラーがなければ「`false`」を返します。

```ruby
# 例: Userモデルで手動でバリデーションをチェック
user = User.new(name: "")  # 名前が空なのでエラーがある
puts user.valid?  # => false（エラーあり）
puts user.invalid?  # => true（エラーあり）
``` 

このようにして、**バリデーション**が成功したかどうかを確認できます。

<br>

---

### バリデーションを設定してみる

ActiveRecordには、バリデーションヘルパーが多数用意されており、これらのヘルパーは、共通のバリデーションルールを提供します。
実際にModelを用意してバリデーションを設定してみましょう。

+ **プロジェクトの作成**  
    最初に新しいRailsプロジェクトを作成します。以下のコマンドを使ってプロジェクトを作成し、ディレクトリに移動します。  
    ```sh
    $ rails new validates_sample  # プロジェクトを作成
    $ cd validates_sample         # 作成したプロジェクトのフォルダに移動
    ```

    次に、`User`モデルを作成します。  

    **Userモデル（ユーザー）**のテーブルには以下のカラムを設定します。

    | フィールド名   | 名称           | 型        |
    |---------------|----------------|-----------|
    | id            | ID             | integer   |
    | name          | 名前           | string    |
    | age           | 年齢           | integer   |
    | password      | パスワード     | string    |
    | email         | メールアドレス | string    |

+ **User:MVCを作成**  
    `confirmation` ヘルパーを使ったバリデーションを設定するために、**Viewテンプレート** に記述が必要です。そのため、`scaffold` コマンドを使ってモデル、ビュー、コントローラーなどを一度に作成します。

    以下のコマンドで、`User`モデルを作成し、必要なカラム（`name`, `age`, `password`, `email`）を追加します：
    ```sh
    $ rails g scaffold User name:string age:integer password:string email:string
    ```

    次に、**データベースのマイグレーション** を実行して、`users`テーブルを作成します：
    ```sh
    $ rails db:migrate
    ```

    これで、`User`に関連するMVC（モデル、ビュー、コントローラー）が作成され、データベースにテーブルが追加されます。  

---

#### **presence**  
このヘルパーは、指定された属性が「**空ではない**」ことを確認するために使用します。もし値が `nil` や空文字（空欄やホワイトスペース）であれば、エラーが発生し、データベースに保存できなくなります。つまり、**入力必須**の項目として設定するために使います。

例えば、**`name`**, **`password`**, **`email`** のフィールドにバリデーションを設定する場合、次のように書きます。

```ruby
# app/models/user.rb

class User < ApplicationRecord
  validates :name, :age, :password, presence: true
end
```

このコードでは、**`name`**, **`age`**, **`password`** の3つのフィールドに「空ではない」ことを確認するバリデーションを設定しています。これらのフィールドが空だと、データが保存できません。

さらに、カンマ（`,`）で区切ることで、複数のフィールドを1行でまとめて設定することができます。

---

#### **length**  
`length` ヘルパーは、指定された値の「長さ」を検証するために使用します。いくつかのオプションを使うことで、例えば「何文字以上」「何文字以下」といった細かいバリデーションが可能です。

| オプション       | 意味                                 |
|----------------|------------------------------------|
| `minimum:`      | 指定した値より小さい長さは保存できない |
| `maximum:`      | 指定した値より大きい長さは保存できない |
| `in:` または `within:` | 指定した範囲内の長さでなければならない |
| `is:`            | 指定した長さとぴったり一致しなければならない |

次に、以下のようにフィールドに長さ制限を設定します：

- **`name`** フィールドは「2文字以上」
- **`age`** フィールドは「3文字以内」
- **`password`** フィールドは「6文字以上、20文字以内」

```ruby
# app/models/user.rb

class User < ApplicationRecord
  validates :name, presence: true, length: { minimum: 2 }
  validates :age, presence: true, length: { maximum: 3 }
  validates :password, presence: true, length: { in: 6..20 }
end
```

このコードでは、**`name`** が2文字以上、**`age`** が3文字以内、**`password`** が6文字以上20文字以内であることを確認するバリデーションを設定しています。

---

#### **numericality**  
`numericality` ヘルパーは、指定された値が「数値」であるかどうかを検証します。デフォルトでは整数（`integer`）と浮動小数点数（`float`）が許可され、符号（+、-）も認められています。もし整数だけを許可したい場合は、「`only_integer: true`」を指定します。

例えば、**`age`** フィールドに「整数のみ」を許可する設定を追加するには、次のように書きます：

```ruby
# app/models/user.rb

class User < ApplicationRecord
  validates :name, presence: true, length: { minimum: 2 }
  validates :age, presence: true, length: { maximum: 3 }, numericality: { only_integer: true }
  validates :password, presence: true, length: { in: 6..20 }
end
```

このコードでは、**`age`** フィールドが整数のみであることを確認するバリデーションを設定しています。

---

#### **uniqueness**  
`uniqueness` ヘルパーは、指定したフィールドの値が「一意（ユニーク）」であり、他のレコードと重複していないかを検証します。例えば、ユーザーの名前やメールアドレスなど、一度入力された値が他のユーザーと重複しないことを確認したい場合に使います。

次のように、**`name`** と **`email`** フィールドに一意性を設定できます。

```ruby
# app/models/user.rb
class User < ApplicationRecord
  validates :name, presence: true, length: { minimum: 2 }, uniqueness: true
  validates :age, presence: true, length: { maximum: 3 }, numericality: { only_integer: true }
  validates :password, presence: true, length: { in: 6..20 }
  validates :email, uniqueness: true
end
```

このコードでは、**`name`** と **`email`** フィールドが他のレコードと重複していないことを確認するバリデーションを設定しています。

---

#### **confirmation**  
`confirmation` ヘルパーは、2つの値が完全に一致する必要がある場合に使用します。例えば、パスワードやメールアドレスなど、ユーザーが入力した値と確認用に入力した値が同じであることを確認するために使います。

このヘルパーを使うと、**仮想属性**が作成されます。仮想属性とは、実際のデータベースには存在しないが、フォームで入力された値を処理するための属性です。確認用のフィールドの名前は、元の属性名に「_confirmation」を付けたものになります。

例えば、`password` に入力確認を設定する場合、次のように記述します。

```ruby
# app/models/user.rb

class User < ApplicationRecord
  validates :name, presence: true, length: { minimum: 2 }, uniqueness: true
  validates :age, presence: true, length: { maximum: 3 }, numericality: { only_integer: true }
  validates :password, presence: true, length: { in: 6..20 }, confirmation: true
  validates :password_confirmation, presence: true
  validates :email, uniqueness: true
end
```

このコードでは、`password` フィールドに対して確認用フィールド `password_confirmation` を設定し、両者が一致していることを確認します。また、`password_confirmation` も必須項目として `presence: true` が指定されています。

次に、Viewテンプレートにパスワードと確認用のパスワード入力フィールドを作成します。

```html
<!-- app/views/users/_form.html.erb -->

<div>
  <%= form.label :password, style: "display: block" %>
  <%= form.text_field :password, type: :password %>
</div>

<div>
  <%= form.label :password_confirmation, style: "display: block" %>
  <%= form.text_field :password_confirmation, type: :password %>
</div>
```

`password` フィールドは `type: :password` を使って非表示（暗号化）で入力できるようにしています。また、`password_confirmation` も同様に非表示で確認できます。

>**パスワードのハッシュ化**  
>セキュリティの観点から、ユーザーのパスワードなどの機密情報は**ハッシュ化**して保存することが推奨されます。ハッシュ化とは、パスワードをランダムな文字列に変換することで、元のパスワードを逆算できなくする処理です。Railsでは通常、`bcrypt`という暗号化ハッシュ関数を使用してパスワードを安全に保存します。  
>`bcrypt`により、パスワードはデータベースにそのまま保存されず、ハッシュ化された形で保存されます。ハッシュ化されたパスワードは、万が一データが漏洩しても元のパスワードを知ることができません。パスワードのセキュリティについては、後で紹介するログイン認証で使用する `devise` gemを用いた方法でさらに詳しく説明します。

---

#### **format**  
`format` ヘルパーは、入力された値が指定された正規表現と一致するかどうかを検証します。このバリデーションを使用すると、特定のパターン（例えば、メールアドレスや電話番号の形式）に従った入力がされているかをチェックできます。

たとえば、`email` フィールドにメールアドレスの形式を設定する場合、次のように記述します。`message` オプションを使って、エラーが発生した場合に表示するカスタムメッセージも設定できます。

```ruby
# app/models/user.rb

validates :name, presence: true, length: { minimum: 2 }, uniqueness: true
validates :age, presence: true, length: { maximum: 3 }, numericality: { only_integer: true }
validates :password, presence: true, length: { in: 6..20 }, confirmation: true
validates :password_confirmation, presence: true
validates :email, format: { with: /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i,
                            message: "使用できない文字が含まれているか形式に誤りがあります。" }, uniqueness: true
```

このコードでは、`email` フィールドに対して、次のような正規表現が使われています：

- `\A`: 文字列の始まりを示す
- `[\w+\-.]+`: 英数字、プラス記号、ドット、ハイフンを含む1文字以上
- `@`: アットマーク
- `[a-z\d\-.]+`: 英小文字、数字、ドット、ハイフンを含む1文字以上
- `\.[a-z]+`: ドットに続く英小文字（ドメイン名）
- `\z`: 文字列の終わりを示す

これにより、メールアドレスの一般的な形式（例：`example@example.com`）に一致するかが確認されます。エラーが発生した場合、指定されたメッセージ「使用できない文字が含まれているか形式に誤りがあります。」が表示されます。  

<br>

---

### バリデーション実行時の動作を確認してみる

先ほど作成した `User` モデルを使って、バリデーションが正しく動作するかを確認しましょう。  

まず、コンソールを起動します。ターミナルで次のコマンドを実行してください：

```sh
$ rails c
```

次に、コンソールから `User` オブジェクトを作成し、変数 `u` に格納します：

```sh
irb(main) > u = User.new
```

この時点で、`User` オブジェクトが作成され、`u` に格納されますが、まだ属性には何も設定されていません。

次に、`valid?` メソッドを使ってバリデーションを実行してみます。`valid?` は、オブジェクトがバリデーションを通過するかどうかを確認するメソッドで、通過すれば `true` を、通らなければ `false` を返します。

```sh
irb(main) > u.valid?  # => false
```

この結果、`false` が返されます。なぜなら、`User` モデルに設定したバリデーション（例えば `presence` や `length`）を `u` が満たしていないからです。具体的には、名前やパスワードなどの必須項目が空であり、バリデーションが失敗しているためです。

このように、`valid?` メソッドを使うことで、モデルが設定したバリデーションを実行して、データが正しいかどうかを確認できます。  

---

### バリデーションエラーの詳細を見る
先ほど `valid?` を使って確認した `User` オブジェクトのバリデーションエラーについて、さらに詳しい情報を確認してみましょう。  

#### `errors.details` を使ってエラーの詳細を見る
`errors.details` を使うことで、エラーが発生した属性に関する詳細な情報を確認できます。次のように入力してみましょう：

```sh
irb(main) > u.errors.details
```

これにより、以下のようなエラーの詳細が表示されます：

```sh
=> {:name=>[{:error=>:blank}, {:error=>:too_short, :count=>3}], :age=>[{:error=>:blank}, {:error=>:not_a_number, :value=>nil}], :password=>[{:error=>:blank}, {:error=>:too_short, :count=>6}], :password_confirmation=>[{:error=>:blank}], :email=>[{:error=>:invalid, :value=>nil}]}
```

- `name` に関しては、空である (`:blank`) と、短すぎる (`:too_short`) というエラーが発生しています。
- `age` については、空である (`:blank`) と、数値ではない (`:not_a_number`) というエラーがあります。
- `password` は空である (`:blank`) と、短すぎる (`:too_short`) というエラーです。
- `password_confirmation` は空 (`:blank`) です。
- `email` は無効な形式 (`:invalid`) です。

#### `errors.messages` を使ってエラーメッセージを見る

さらに、ユーザーに表示されるエラーメッセージを確認するには、`errors.messages` を使用します。次のコマンドでエラーメッセージを確認できます：

```sh
irb(main) > u.errors.messages
```

このコマンドで表示されるエラーメッセージは次の通りです：

```sh
=> {:name=>["can't be blank", "is too short (minimum is 3 characters)"], :age=>["can't be blank", "is not a number"], :password=>["can't be blank", "is too short (minimum is 6 characters)"], :password_confirmation=>["can't be blank"], :email=>["使用できない文字が含まれているか形式に誤りがあります。"]}
```

| フィールド              | エラーメッセージ                                           |
|----------------------|---------------------------------------------------|
| **name**             | "can't be blank", "is too short (minimum is 3 characters)" |
| **age**              | "can't be blank", "is not a number"                  |
| **password**         | "can't be blank", "is too short (minimum is 6 characters)" |
| **password_confirmation** | "can't be blank"                                  |
| **email**            | "使用できない文字が含まれているか形式に誤りがあります。" |

このように、`errors.details` と `errors.messages` を使うことで、バリデーションエラーの詳細情報を簡単に取得できます。

---

### `form_with`ヘルパーとは

Rails 5.1から、`form_for`や`form_tag`の代わりに使える新しいヘルパー`form_with`が追加されました。これにより、`form_for`や`form_tag`は今後使わなくていい、または非推奨となります。`form_with`は、フォームを簡単に作成できる便利なヘルパーです。

まずは、プロジェクトを作成して、フォームがどのように動くのかを確認してみましょう。

```sh
$ rails new form_sample                   # 新しいRailsプロジェクトを作成
$ cd form_sample                          # 作成したプロジェクトのディレクトリに移動
$ rails g scaffold User name age:integer  # ユーザーの名前と年齢を持つUserモデルを作成
$ rails db:migrate                        # データベースを更新
```

次に、フォームのコードを見てみましょう。

```html
<!-- app/views/users/_form.html.erb -->

<%= form_with(model: user, local: true) do |form| %>
  <% if user.errors.any? %>
    <div id="error_explanation">
      <h2><%= pluralize(user.errors.count, "error") %> prohibited this user from being saved:</h2>

      <ul>
        <% user.errors.full_messages.each do |message| %>
          <li><%= message %></li>
        <% end %>
      </ul>
    </div>
  <% end %>

  <div class="field">
    <%= form.label :name %>       <!-- 名前のラベル -->
    <%= form.text_field :name %>  <!-- 名前の入力欄 -->
  </div>

  <div class="field">
    <%= form.label :age %>         <!-- 年齢のラベル -->
    <%= form.number_field :age %>  <!-- 年齢の入力欄 -->
  </div>

  <div class="actions">
    <%= form.submit %>  <!-- フォーム送信ボタン -->
  </div>
<% end %>
```

`form_with`は、フォームを作成するためのヘルパーです。  

- `model: user` → フォームが`User`モデルに基づいて作成されることを指定  
- `local: true` → フォームを通常の送信（ページをリロードする形）で動作させる設定  

この`form_with`のブロック引数`form`は、**FormBuilderオブジェクト**です。  
このオブジェクトを使うと、簡単にフォームの要素を作成できます。  

例えば、以下のコードは、それぞれのフォーム要素を生成します。  

- `form.label :name` → 「Name」というラベルを作成  
- `form.text_field :name` → 名前を入力するテキストフィールドを作成  

このように、Railsは **`User`モデルの情報をもとに自動でHTMLを生成** してくれます。

---

##### 送信されたデータ

`form_with`で作成したフォームに入力された値は、コントローラーで`params[:name]`や`params[:age]`として受け取ることができます。

ブラウザでデベロッパーツールを開くと、生成されたHTMLコードは以下のようになります。

```html
<form action="/users" accept-charset="UTF-8" method="post">
  <input type="hidden" name="authenticity_token" value="v/nQIldmxgikiUxiDxQ66PjTHUELCU99tfz2jcmyQ5eNLrLup0aprYlPLCaOM56fP/htHiXoW5lbynU17psWkQ==" />

  <div class="field">
    <label for="user_name">Name</label>
    <input type="text" name="user[name]" id="user_name" />
  </div>

  <div class="field">
    <label for="user_age">Age</label>
    <input type="number" name="user[age]" id="user_age" />
  </div>

  <div class="actions">
    <input type="submit" name="commit" value="Create User" data-disable-with="Create User" />
  </div>
</form>
```

---

##### 実際にフォームを表示する

サーバーを起動し、実際にフォームがどのように表示されるか確認してみましょう。

![画像](images/08-4-4.png)

```sh
$ rails s  # サーバーを起動
```

その後、ブラウザで`http://localhost:3000/users/new`にアクセスすると、フォームが表示されます。フォームに名前や年齢を入力して「Create User」をクリックすると、新しいユーザーが作成されます。

このように、`form_with`を使うことで、簡単にフォームを作成し、データを送信することができます。

---

#### `form_with`ヘルパーの使い方

`form_with`ヘルパーにはさまざまなオプションが用意されています。  
`scaffold`コマンドで生成されたフォームには、`:model`オプションと`:local`オプションが指定されていました。

```ruby
form_with(model: user, local: true)
```

その他にもさまざまなオプションが用意されています。  

| オプション | 説明 | デフォルト値 |
|-----------|--------------------------------|--------------|
| `:model`  | どのモデルに基づいてフォームを作成するか指定 | なし |
| `:url`    | フォームの送信先URLを指定 | 自動生成 |
| `:method` | HTTPメソッド（`GET` / `POST` など）を指定 | `POST` |
| `:format` | 送信データの形式を指定 | `text/html` |
| `:id`     | フォームの`id`属性を指定 | なし |
| `:class`  | フォームの`class`属性を指定 | なし |
| `:data`   | `data-*`属性を指定 | なし |
| `:html`   | `id`, `class`, `data` 以外のHTML属性を指定 | なし |

>他にも複数オプションが用意されています。  
>ここでは説明しませんが、他にもモデルに基づかないフォームを生成やform_forとform_withの違いなど調べてみると良いでしょう。

`form_with`を使うと、モデルの情報に基づいたフォームを簡単に作成できます。  
また、`:url` や `:method` などを指定することで、送信先やリクエストの方法を柔軟にカスタマイズできます。

---

### 独自のバリデーションを作成しよう  

バリデーションとは、**データが適切かどうかをチェックする仕組み**です。  
Railsでは、`validate` メソッドを使って、自分でルールを決めた**カスタムバリデーション**を作成できます。  

例えば、「**ユーザーの年齢が12歳以上でなければならない**」というルールを設定してみましょう。  

#### カスタムバリデーションの例  
```rb
class User < ApplicationRecord
  validate :must_be_twelve_or_older  # ❶ バリデーションを設定

  private

  def must_be_twelve_or_older  # ❷ 独自のバリデーションを定義
    if age.present? && age < 12
      errors.add(:age, "must be at least 12 years old")  # ❸ エラーメッセージを追加
    end
  end
end
```

---

#### カスタムバリデーションの作り方  
1. **`validate` メソッドでバリデーションを設定**する  
   - 例: `validate :must_be_twelve_or_older`（`must_be_twelve_or_older` というメソッドを呼び出す）  
2. **独自のメソッドを作成して、チェックしたい条件を定義**する  
   - 例: `def must_be_twelve_or_older` の中で `age` の値をチェック  
3. **条件を満たさないときに `errors.add` でエラーメッセージを追加**する  
   - `errors.add(:age, "must be at least 12 years old")`（"12歳以上でなければなりません" というエラーを追加）

このように、独自のルールを作成して、モデルのデータを適切に管理することができます。

---

### 練習  
新たにアプリを作成してバリデーションを追加しましょう。  
そのとき、通常のバリデーションとカスタムバリデーションを両方使用してください。

>ヒント
>- 作成に迷う人は身長と体重に対するバリデーションを考えてみましょう。
>- 遊園地のアトラクションの条件を参考に設定してみるのもいいかもしれません。