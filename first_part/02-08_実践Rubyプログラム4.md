# 2 実践Rubyプログラム

## 目次
+ [RPGバトルについて](#rpgバトルについて)

<br>

---

## ほしい機能を追加しよう
ここまで基本的な部分を作ってきました。より良いゲームに仕上げるために、応用としてオリジナル機能を作ってみましょう！以下はそのサンプルです。

---

### キャラクターの生存状況を表示

```sh
・【リバティ】 HP：6 こうげき力：6
・【魔法使い】 HP：4 こうげき力：8
・【オーク】 HP：14 こうげき力：8
×【ゴブリン】 HP：0 こうげき力：6
```

死滅しているキャラクターは×印がつきます。

---

### 回復魔法

```sh
↓行動を選択してください↓
【1】こうげき
【2】回復
【3】逃げる
2
勇者は回復の魔法を唱えた！
勇者のHPが 10 回復した！（現在のHP：30）
```

回復処理を作ります。HPとは違って加算することで実現できます。アイテムなんかにしてもよさそうです。

---

### 魔法こうげき（強化）

```sh
勇者 のこうげき！
→ゴブリン に 8 ダメージ！
魔法使いの魔法こうげき！
→オーク に 28 ダメージ！
```

現在は文章のみの違いですが、魔法こうげきが発動した際には威力を増大させます。

---

### 命中率

```sh
勇者 の こうげき！
→しかし勇者のこうげきは外れた！
魔法使い の 魔法こうげき！
→呪文を噛んでしまった！
→ゴブリン に 2 ダメージ！
```

命中率を加えて攻撃が当たらなかったりするのも面白みがありますね。ちょっと弱めの攻撃が当たるのもよさそうです。

---

### コンティニュー

```sh
◆◆◆ GAME OVER ◆◆◆

コンティニューしますか？
【1】する
【2】しない
1 # ユーザーが入力

◆◆◆ モンスターが現れた！ ◆◆◆
```

実際にゲームで遊ぶ時に、負けたらシステム自体が終了するゲームはそうそう無いですよね。もう一度やり直す機会をプレイヤーに与えてみましょう。

---

### 必殺技

```sh
勇者のサンダーソード！
→オーク に 10 のダメージ！
→ゴブリン に 10 のダメージ！
```

全体攻撃できる必殺技の例です。

---

### 状態異常

```sh
魔法使いの魔法こうげき！
→オーク に 8 のダメージ！
→オーク はマヒしてしまった！
オークはしびれてうごけない！
```

こうげきを食らって状態に異常が発生することによって、また新たな展開を生むことができます。眠らされたり、氷漬けにされたり...。それらを解消するアイテムや魔法などを作ってみてもいいですね。

---

### メッセージ表示間隔

市販のゲームでは、戦闘中のテキストはちょっとずつ表示されると思います。通常のコードだと待たずに一瞬で表示されるので、1秒ごとに表示する処理などを取り入れてみても良さそうです。

---

## おまけ
本テキストで学習した内容を取り入れて、そこにオリジナル機能を考えて取り入れてみたコードになります。気になるものがあったら参考にしてみてください。  

このコードの特徴は以下のとおりです。

+ Messageクラスで表示されるメッセージを一元管理
+ 画面の文字に色をつけるオリジナル機能
+ メッセージの表示間隔を追加
+ メッセージを出力するメソッドで処理を統一化
+ 三項演算子を活用するなど、短く簡潔な書き方を意識
+ 一部の変数や定数を短く定義しなおして読みやすくしている

```rb
# 定数管理クラス
class Constants
  # ステータス
  HP_MIN = 0           # HP最小値
  ATTACK_VARIANCE = 3  # こうげき力のブレ幅

  # 行動選択
  ACTION_ATTACK = 1  # こうげき
  ACTION_ESCAPE = 2  # 逃げる

  # こうげきタイプ
  ATTACK_TYPE_NORMAL = 1  # 通常
  ATTACK_TYPE_MAGIC = 2   # 魔法こうげき
  
  # 書き出し間隔(秒)
  MESSAGE_DISPLAY_INTERVAL  = 1
end

# 各種表示メッセージを管理するクラス
class Message
  # 名前の入力をユーザーに求める
  def self.enter_name
    "↓勇者の名前を入力してください↓"
  end

  # ゲーム開始
  def self.game_start
    color("magenta", "\n◆◆◆ モンスターが現れた！ ◆◆◆")
  end

  # ラウンド数
  def self.round(round)
    color("cyan", "\n=== ラウンド #{round} ===")
  end

  # キャラクターのステータス
  def self.status(character)
    mark = character.is_alive ? "・" : color("red", "×")  # マーカー（生存:死滅）
    name = character.name                                 # 名前
    hp = character.hp                                     # HP
    attack_damage = character.attack_damage               # こうげき力

    "#{mark}【#{name}】 HP：#{hp} こうげき力：#{attack_damage}"
  end

  # 操作
  def self.action_choice(hero)
    name = hero.name                    # 名前
    attack = Constants::ACTION_ATTACK   # こうげきの値
    escape = Constants::ACTION_ESCAPE   # 逃げるの値

    "\n#{name} のターンです。\n↓行動を選択してください↓\n" + color("yellow", "【#{attack}】こうげき\n【#{escape}】逃げる")
  end

  # 無効な選択肢が入力された
  def self.invalid_choice
    color("blue", "無効な選択肢です。再度選んでください。")
  end

  # こうげき
  def self.attack(attacker)
    name = attacker.name                            # 名前
    type = attacker.attack_type                     # タイプ
    normal_attack = Constants::ATTACK_TYPE_NORMAL   # 通常こうげきの値
    magic_attack = Constants::ATTACK_TYPE_MAGIC     # 魔法こうげきの値

    # こうげきタイプによってメッセージを変える
    case type
    when normal_attack
      # 通常こうげき
      return "#{name} のこうげき！"
    when magic_attack
      # 魔法こうげき
      return "#{name} は呪文をとなえた！"
    end
  end

  # ダメージ
  def self.damage(target, damage)
    name = target.name   # 名前

    "→#{name} に #{damage} のダメージ！"
  end

  # キャラクター死滅
  def self.death(defender)
    name = defender.name   # 名前

    color("yellow", "→#{name} は死滅した！")
  end

  # 逃げる
  def self.escape(character)
    name = character.name  # 名前

    color("yellow", "#{name} は逃げ出した！\n")
  end

  # 勝敗
  def self.judge(hero_alive)
    hero_alive ? color("green", "◆◆◆ 勇者パーティの勝利！ ◆◆◆") : game_over()
  end

  # ゲームオーバー
  def self.game_over
    color("red", "◆◆◆ GAME OVER ◆◆◆")
  end

  # テキストに色付け
  def self.color(color, text)
    color_codes = {
      "red" => 31,
      "green" => 32,
      "yellow" => 33,
      "blue" => 34,
      "magenta" => 35,
      "cyan" => 36,
    }
  
    color_code = color_codes[color.downcase]
    color_code ? "\e[#{color_code}m#{text}\e[0m" : text
  end
end

# キャラクタークラス
class Character
  # アクセサ
  attr_accessor :name, :hp, :attack_damage, :attack_type ,:is_player, :is_alive

  # キャラクターの初期設定を行う
  def initialize(name, hp, attack_damage, attack_type, is_player = false)
    @name = name                    # キャラクター名
    @hp = hp                        # HP
    @attack_damage = attack_damage  # こうげき力
    @attack_type = attack_type      # こうげきタイプ
    @is_player = is_player          # プレイヤーフラグ
    @is_alive = true                # 生存フラグ
  end

  # ダメージ計算処理
  def calculate_damage
    variance = Constants::ATTACK_VARIANCE  # こうげき力のブレ幅

    # ダメージをランダムに決定(ステータスのこうげき力 ± ブレ幅)
    rand(@attack_damage - variance..@attack_damage + variance)
  end

  # ダメージ反映処理
  def receive_damage(damage)
    hp_min = Constants::HP_MIN # 0定義

    @hp -= damage  # ダメージ処理

    # 死滅処理
    if @hp <= hp_min
      @hp = hp_min        # HPが0未満にならないよう調整 
      @is_alive = false   # 生存フラグを下ろす
    end
  end
end

# ゲーム進行クラス
class Game
  # ゲームの初期設定を行う
  def initialize
    # 逃げるフラグを定義
    @escape_flg = false

    # プレイヤーに勇者の名前を入力させる
    display_message(Message.enter_name())  # メッセージ表示
    hero_name = gets.chomp              # 入力受付
    
    # キャラクターの作成
    @heroes = create_heroes(hero_name)  # 勇者パーティ
    @monsters = create_monsters()       # モンスターパーティ

    # 全パーティを格納
    @all_parties = [@heroes, @monsters]
  end

  # ゲーム開始処理
  def start
    round = 0    # ターン数

    # ゲーム開始メッセージ
    display_message(Message.game_start())

    # 戦闘ループ
    loop do
      # ゲームの戦況
      round += 1                            # ラウンド数カウント
      display_message(Message.round(round)) # ラウンド数表示
      show_status(@heroes)                  # ステータスの表示(勇者パーティ)
      show_status(@monsters)                # ステータスの表示(モンスターパーティ)

      # 勇者パーティのターン
      heroes_turn()
      break if @all_parties.any? { |party| party_destroyed?(party) } || @escape_flg  # 全滅チェックと逃げるフラグチェック

      # モンスターパーティのターン
      monsters_turn()
      break if @all_parties.any? { |party| party_destroyed?(party) } # 全滅チェック
    end

    # 勝敗表示
    unless @escape_flg
      # 通常の勝敗メッセージ
      display_message(Message.judge(party_destroyed?(@monsters)))
    else
      # 逃げ出した場合
      display_message(Message.game_over()) # ゲームオーバーの表示
    end
  end

  private

  #  勇者パーティの作成
  def create_heroes(hero_name)
    normal_attack = Constants::ATTACK_TYPE_NORMAL # 通常こうげきの値
    magic_attack = Constants::ATTACK_TYPE_MAGIC   # 魔法こうげきの値

    [
      Character.new(hero_name, 30, 6, normal_attack, true),  # プレイヤーが操作する勇者
      Character.new('魔法使い', 20, 8, magic_attack)          # 魔法使い(CPU)
    ]
  end

  # モンスターパーティの作成
  def create_monsters
    normal_attack = Constants::ATTACK_TYPE_NORMAL # 通常こうげきの値
    [
      Character.new('オーク', 30, 8, normal_attack),   # オーク(CPU)
      Character.new('ゴブリン', 25, 6, normal_attack)  # ゴブリン(CPU)
    ]
  end

  # メッセージ表示
  def display_message(message, wait = false)   # (文字列, 待機時間の有無)
    interval = Constants::MESSAGE_DISPLAY_INTERVAL  # 表示待機時間

    puts message            # 表示
    sleep interval if wait  # 指定がある場合は待つ
  end
  
  # パーティのステータスを表示する
  def show_status(party)
    party.each { |character| display_message(Message.status(character)) }
  end

  # 勇者パーティ側のターンを処理
  def heroes_turn
    attack_action = Constants::ACTION_ATTACK  # こうげき
    escape_action = Constants::ACTION_ESCAPE  # 逃げる
    
    @heroes.each do |character|
      next unless character.is_alive # 死滅したキャラクターは行動をスキップ
      loop do

        # 行動選択
        if character.is_player
          # プレイヤーの処理
          display_message(Message.action_choice(character))  # メッセージ
          choice = gets.to_i                                 # 選択を取得
        else
          # 味方の処理
          choice = attack_action  # こうげきを常時選択
        end

        # 行動
        case choice
        when attack_action
          # こうげき
          target_monster = @monsters.select(&:is_alive).sample          # 対象を絞る
          execute_attack(character, target_monster) if target_monster   # こうげき処理
          break
        when escape_action
          # 逃げる
          execute_escape(character)   # 逃げる処理
          return
        else
          # 無効な選択
          display_message(Message.invalid_choice())  # エラーメッセージ
        end
      end
    end
  end

  # モンスター側のターンを処理
  def monsters_turn
    @monsters.each do |monster|
      next unless monster.is_alive  # 死滅したキャラクターはスキップ

      # こうげき
      attack_target = @heroes.select(&:is_alive).sample         # 対象を絞る
      execute_attack(monster, attack_target) if attack_target   # こうげき処理
    end
  end

  # こうげき共通
  def execute_attack(attacker, defender)
    # こうげきメッセージ
    display_message(Message.attack(attacker), true)

    # ダメージ処理
    damage = attacker.calculate_damage()                      # ダメージ計算
    defender.receive_damage(damage)                           # ダメージ反映
    display_message(Message.damage(defender, damage), true)   # メッセージ

    # 死滅メッセージ
    display_message(Message.death(defender), true) unless defender.is_alive
  end

  # 逃げる処理
  def execute_escape(character)
    @escape_flg = true                                  # 逃げるフラグ
    display_message(Message.escape(character), true)    # 逃げる表示
  end

  # パーティの全滅チェック
  def party_destroyed?(party)
    party.none?(&:is_alive)  # 全滅ならtrue
  end
end

# ゲーム開始
game = Game.new
game.start
```