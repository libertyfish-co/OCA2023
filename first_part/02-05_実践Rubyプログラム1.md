# 2 実践Rubyプログラム

## 目次
+ [RPGバトルについて](#rpgバトルについて)
  + [ゲームの目的](#ゲームの目的)
  + [プログラムの流れ](#プログラムの流れ)
+ [RPGバトルを作ろう](#rpgバトルを作ろう)
  + [ゲーム進行クラスを作ろう](#ゲーム進行クラスを作ろう)
  + [キャラクタークラスを作ろう](#キャラクタークラスを作ろう)
  + [定数クラスを作ろう](#定数クラスを作ろう)
  + [メソッドを活用しよう](#メソッドを活用しよう)


<br>

---

## RPGバトルについて

このテキストでは、**Rubyを使ってシンプルなRPGバトル**を実装します。  
**ターン制バトルを作りながら、Rubyの基本的な構文や概念を復習**します。  
また、本テキストの**サンプルコードに登場する変数は、自身がわかりやすいように適切に置き換えていただいて構いません**。

---

### ゲームの目的

このゲームの目的は、**プレイヤー（勇者）** と **コンピューターが操作するモンスター** による **ターン制バトル** を実装することです。  
プレイヤーは **攻撃や魔法を駆使してモンスターを倒し、勝利を目指します**。


+ **完成イメージ（例）**

  ```sh
  # 勝利パターン

  ↓勇者の名前を入力してください↓
  リバティ # ユーザーの入力

  ◆◆◆ モンスターが現れた！ ◆◆◆

  === ターン 1 ===
  ・【リバティ】 HP：30 こうげき力：6
  ・【魔法使い】 HP：20 こうげき力：8
  ・【オーク】 HP：30 こうげき力：8
  ・【ゴブリン】 HP：25 こうげき力：6

  リバティ のターンです。
  ↓行動を選択してください。↓
  【1】こうげき
  【2】逃げる
  1 # ユーザーの入力
  リバティ のこうげき！
  →ゴブリン に 4 のダメージ！
  魔法使い は呪文をとなえた！
  →オーク に 9 のダメージ！
  オーク のこうげき！
  →リバティ に 10 のダメージ！
  ゴブリン のこうげき！
  →リバティ に 6 のダメージ！

  === ターン 2 ===
  ・【リバティ】 HP：14 こうげき力：6
  ・【魔法使い】 HP：20 こうげき力：8
  ・【オーク】 HP：21 こうげき力：8
  ・【ゴブリン】 HP：21 こうげき力：6

  リバティ のターンです。
  ↓行動を選択してください。↓
  【1】こうげき
  【2】逃げる
  1 # ユーザーの入力
  リバティ のこうげき！
  →ゴブリン に 5 のダメージ！
  魔法使い は呪文をとなえた！
  →ゴブリン に 7 のダメージ！
  オーク のこうげき！
  →魔法使い に 11 のダメージ！
  ゴブリン のこうげき！
  →魔法使い に 5 のダメージ！

  ...

  === ターン 4 ===
  ・【リバティ】 HP：6 こうげき力：6
  ・【魔法使い】 HP：4 こうげき力：8
  ・【オーク】 HP：14 こうげき力：8
  ×【ゴブリン】 HP：0 こうげき力：6

  リバティ のターンです。
  ↓行動を選択してください。↓
  【1】こうげき
  【2】逃げる
  1 # ユーザーの入力
  リバティ のこうげき！
  →オーク に 9 のダメージ！
  魔法使い は呪文をとなえた！
  →オーク に 10 のダメージ！
  →オーク は死滅した！
  ◆◆◆ 勇者パーティの勝利！ ◆◆◆
  ```

  <details>
  <summary>もっと見る</summary>

  ```sh
  # 敗北パターン
  
  ↓勇者の名前を入力してください↓
  リバティ # ユーザーの入力
  ◆◆◆ モンスターが現れた！ ◆◆◆

  === ターン 1 ===
  ・【リバティ】 HP：30 こうげき力：6
  ・【魔法使い】 HP：20 こうげき力：8
  ・【オーク】 HP：30 こうげき力：8
  ・【ゴブリン】 HP：25 こうげき力：6

  リバティ のターンです。
  ↓行動を選択してください。↓
  【1】こうげき
  【2】逃げる
  1 # ユーザーの入力
  リバティ のこうげき！
  →ゴブリン に 6 のダメージ！
  魔法使い は呪文をとなえた！
  →ゴブリン に 5 のダメージ！
  オーク のこうげき！
  →リバティ に 9 のダメージ！
  ゴブリン のこうげき！
  →魔法使い に 8 のダメージ！

  === ターン 2 ===
  ・【リバティ】 HP：21 こうげき力：6
  ・【魔法使い】 HP：12 こうげき力：8
  ・【オーク】 HP：30 こうげき力：8
  ・【ゴブリン】 HP：14 こうげき力：6

  リバティ のターンです。
  ↓行動を選択してください。↓
  【1】こうげき
  【2】逃げる
  1 # ユーザーの入力
  リバティ のこうげき！
  →ゴブリン に 3 のダメージ！
  魔法使い は呪文をとなえた！
  →オーク に 10 のダメージ！
  オーク のこうげき！
  →魔法使い に 10 のダメージ！
  ゴブリン のこうげき！
  →リバティ に 7 のダメージ！

  ...

  === ターン 4 ===
  ・【リバティ】 HP：10 こうげき力：6
  ×【魔法使い】 HP：0 こうげき力：8
  ・【オーク】 HP：14 こうげき力：8
  ・【ゴブリン】 HP：4 こうげき力：6

  リバティ のターンです。
  ↓行動を選択してください。↓
  【1】こうげき
  【2】逃げる
  1 # ユーザーの入力
  リバティ のこうげき！
  →オーク に 7 のダメージ！
  オーク のこうげき！
  →リバティ に 11 のダメージ！
  →リバティ は死滅した！
  ◆◆◆ GAME OVER ◆◆◆
  ```
  
  ```sh
  # 逃げるパターン

  ↓勇者の名前を入力してください↓
  リバティ # ユーザーの入力
  ◆◆◆ モンスターが現れた！ ◆◆◆

  === ターン 1 ===
  ・【リバティ】 HP：30 こうげき力：6
  ・【魔法使い】 HP：20 こうげき力：8
  ・【オーク】 HP：30 こうげき力：8
  ・【ゴブリン】 HP：25 こうげき力：6

  リバティ のターンです。
  ↓行動を選択してください。↓
  【1】こうげき
  【2】逃げる
  2 # ユーザーの入力
  リバティ は逃げ出した！
  ◆◆◆ GAME OVER ◆◆◆
  ```

  </summary>

---

### プログラムの流れ
プログラミングをする際には、まず**プログラムの流れ** を把握することが重要です。以下の**フローチャート** は、その流れを例として**簡潔** に示したものです。

<img src="images/実践Rubyプログラム/フロー.png" width="500px">

プログラムの**流れ**を理解した上でコーディングを進めることは非常に効果的です。流れを整理することで、スムーズにプログラミングを進めやすくなります。

また、プログラムの**構成**を考えることも重要です。例えば、**クラス**を作成するか、**メソッド**を用意するかなど、正解は一つではありません。このテキストではお手本のコードに沿って進めますが、最適な**設計**を自分で考えてみるのも良いかもしれません。

いよいよプログラミングに入っていきますが、いきなり大きなプログラムを作るのは非常に難しいです。全体の**イメージ**を持ちながら、部分的に少しずつ組み立てていきましょう。

---

## RPGバトルを作ろう

### ゲーム進行クラスを作ろう
`rpg_battle.rb`ファイルを作成し、**ゲームを進行するクラス**を作りましょう。  
ひとまず**勇者の名前**を決めてもらいましょうか。

```rb
# ゲームを進行するクラス
class Game
  # ゲームの初期設定を行う
  def initialize
    puts "↓勇者の名前を入力してください↓"
    hero_name = gets.chomp        # 入力受付

    puts "勇者の名前は#{hero_name}です。"
  end
end

# ゲーム開始
Game.new
```
>`chomp`メソッドは**改行を消してくれるメソッド**です。これを**gets**に付け忘れると、文字列が表示されるたびに**改行**が入ってしまうので注意しましょう。  

`initialize`は**オブジェクトの生成時に1度だけ実行されるメソッド**なので、**初期設定**としてユーザーから**名前**を受け取ります。  
`Game.new`でオブジェクトを生成して`initialize`を実行します。実行結果は以下のようになります。  
  
```sh
↓勇者の名前を入力してください↓
リバティ # ユーザーが入力
勇者の名前はリバティです。
```

無事に動きましたか？現段階では**勇者の名前**を決めただけです。他にも**ステータス**などの情報を持たせてあげたいですよね。  
そこで、**キャラクター専門のクラス**を作ってあげましょう。

---

### キャラクタークラスを作ろう

`Character`クラスの`initialize`には、各キャラの**ステータス**を割り当てるために、**インスタンス変数**を置きましょう。これによって**オブジェクトごとに違う値**をもたせることができます。  
今回は以下の**ステータス**を想定して用意しています。

+ **キャラクター名**
+ **HP**
+ **こうげき力**
+ **こうげきタイプ**(通常:1 魔法:2)
+ **プレイヤーフラグ**(実際にユーザーが動きを操作するか否か)
+ **生存フラグ**(キャラクターがまだ生存しているか否か)  

```rb 
# キャラクタークラス
class Character
  # アクセサ
  attr_accessor :name, :hp, :attack_damage, :attack_type ,:is_player, :is_alive

  # キャラクターの初期設定を行う
  def initialize(name, hp, attack_damage, attack_type, is_player = false)
    @name = name                    # キャラクター名
    @hp = hp                        # HP
    @attack_damage = attack_damage  # こうげき力
    @attack_type = attack_type      # こうげきタイプ
    @is_player = is_player          # プレイヤーフラグ
    @is_alive = true                # 生存フラグ
  end
end
```

インスタンス変数にアクセスするためには**アクセサ**(`attr_accessor`)を記述しておきます。  
また、`initialize`の実引数にそれぞれのインスタンス変数に対応する変数を入れています。  

>今回は**勇者(主人公)以外のキャラクターの操作を行うことは想定しない**ので、仮引数に`is_player`の値を入れなかった場合は`false`が自動的に入ります。  
>キャラクターは**生成時には必ず生存している**ので`is_alive`は常に`true`となり、引数を用意する必要はありません。直接`true`を入れておきます。  

これらが正しく記述できているか**動かして確かめてみましょう**。

先ほど作った`Game`クラスの`initialize`に**`hero`**というインスタンス変数を作り、`Character`クラスを呼び出し引数を渡してインスタンスを生成します。  
結果が次のようになるように呼び出してみましょう。  

```sh
↓勇者の名前を入力してください↓
リバティ # ユーザーが入力
キャラクター名：リバティ
HP：30
こうげき力：6
こうげきタイプ：1
プレイヤーフラグ：true
生存フラグ：true
```

<details>
<summary>コード例(クリックすると開きます)</summary>

```rb
# ゲームを進行するクラス
class Game
  # ゲームの初期設定を行う
  def initialize
    puts "↓勇者の名前を入力してください↓"
    hero_name = gets.chomp  # 入力受付
    
    # キャラクターを作成
    @hero = Character.new(hero_name, 30, 6, 1, true)  # (キャラクター名, HP, こうげき力, こうげきタイプ, プレイヤーフラグ) 
    
    # 正しくセットされたか確認
    puts "キャラクター名：#{@hero.name}"
    puts "HP：#{@hero.hp}"
    puts "こうげき力：#{@hero.attack_damage}"
    puts "こうげきタイプ：#{@hero.attack_type}"
    puts "プレイヤーフラグ：#{@hero.is_player}"
    puts "生存フラグ：#{@hero.is_alive}"
  end
end
```
</details>

インスタンス変数を通して呼び出すことができたら、同様に**敵のキャラクター**として**オーク**(`ork`)も作ってみましょう。

```sh
キャラクター名：オーク
HP：30
こうげき力：8
こうげきタイプ：1
プレイヤーフラグ：false
生存フラグ：true
```

<details>
<summary>コード例(クリックすると開きます)</summary>

```rb
@hero = Character.new(hero_name, 30, 6, 1, true)
@ork = Character.new('オーク', 30, 8, 1)
```
</details>

うまくキャラクターの作成を行うことができましたね。  

<br>

---

### 定数クラスを作ろう

先ほど作ったキャラクターのオブジェクトには、こうげきタイプを持たせています。
```rb
attack_type = 1  # こうげきタイプ(通常:1 魔法:2)
puts attack_type #=> 1
```
サンプルコードを見てみると「`1`」なら「通常こうげき」、「`2`」なら「魔法こうげき」とコメントを入れてある通り、基本的に**値**でタイプを割り当てていますね。「`通常こうげき`」といった**文字列**を変数に持たせることももちろん可能ですが、**値の比較**や**コードの保守**の観点から見るとあまり好ましくないので避けるべきです。  

もし、このコメントがなければどうなるでしょうか？

```rb
attack_type = 1  # こうげきタイプ
puts attack_type #=> 1
```
数字だけを見ても一体**何の数字なのか**がわからなくなります。このようによくわからない数字のことを**マジックナンバー**と言います。

**マジックナンバー**を生み出さないために、極力**定数**にできるものは**定数**として宣言してあげましょう。  
以下のように**定数クラス**を作り、**定数**を宣言します。

```rb
# 定数クラス
class Constants
  # こうげきタイプ
  ATTACK_TYPE_NORMAL = 1 # 通常こうげき
  ATTACK_TYPE_MAGIC = 2  # 魔法こうげき
end
```

`1`という数字の代わりに`ATTACK_TYPE_NORMAL`、`2`という数字の代わりに`ATTACK_TYPE_MAGIC`**定数**が使えるようになりました。  
これを呼び出して**キャラクターのオブジェクト**を作成してみます。

```rb
# 勇者の例
Character.new(hero_nm, 30, 6, Constants::ATK_TYPE_NORMAL, true)
```

こうげきタイプは変わらず`1`を示します。

```sh
↓勇者の名前を入力してください↓
リバティ # ユーザーが入力
キャラクター名：リバティ
HP：30
こうげき力：6
こうげきタイプ：1
プレイヤーフラグ：true
生存フラグ：true
```

また、**定数**を使うことにより、コード全体で**値を一元管理**できるようになります。たとえば、通常こうげきは`1`だったけれど、やっぱり`3`にしたい場合、**定義されている定数**の値を`3`に変更するだけで、**コード全体を修正せずにすみます**。

<br>

---

### メソッドを活用しよう

今後キャラが増えることを見据えると、すべてを`initialize`に書くのは**可読性の低下**を招いてしまいます。  
また、現時点では**勇者**と**オーク**しかいないため**味方**と**敵**が明確ですが、増えていくと**管理をするのが大変**になります。  

これらを整理するために、**味方を生成するメソッド**、**敵を生成するメソッド**を作ってみます。  
コードは以下のようになります。

```rb
# 例

# ゲームを進行するクラス
class Game
  # ゲームの初期設定を行う
  def initialize
    puts "↓キャラクターの名前を入力してください↓"
    hero_name = gets.chomp  # 入力受付
    
    # キャラクターを作成
    @heroes = create_heroes(hero_name)
    @monsters = create_monsters()

    # キャラクターが生成されていることを確認
    puts "\nキャラクター名：#{@heroes.name}"
    puts "HP：#{@heroes.hp}"
    puts "こうげき力：#{@heroes.attack_damage}"
    puts "こうげきタイプ：#{@heroes.attack_type}"
    puts "プレイヤーフラグ：#{@heroes.is_player}"
    puts "生存フラグ：#{@hero.is_alive}"

    # モンスターが生成されていることを確認
    puts "\nモンスター名：#{@monsters.name}"
    puts "HP：#{@monsters.hp}"
    puts "こうげき力：#{@monsters.attack_damage}"
    puts "こうげきタイプ：#{@monsters.attack_type}"
    puts "プレイヤーフラグ：#{@monsters.is_player}"
    puts "生存フラグ：#{@monsters.is_alive}"
  end

  private

  # 勇者パーティの作成
  def create_heroes(hero_name)
    Character.new(hero_name, 30, 6, Constants::ATTACK_TYPE_NORMAL, true)  # プレイヤーが操作する勇者
  end

  # モンスターの作成
  def create_monsters
    Character.new('オーク', 30, 8, Constants::ATTACK_TYPE_NORMAL)   # オーク(CPU)
  end
end
```

基本的に**Rubyのメソッド**では、`return`などでメソッドを抜ける処理が実行されない場合、最後に評価された式の値やオブジェクトが**呼び出し元に返されます**（もちろん、明示的に`return`を記述することも可能です）。  
そのため、`@heroes`には**勇者パーティ**のキャラクターが、`@monsters`には**敵パーティ**のキャラクターがそれぞれ格納されています。  

実行すると、以下のような結果になります。

```rb
↓勇者の名前を入力してください↓
リバティ # ユーザーが入力

キャラクター名：リバティ
HP：30
こうげき力：6
こうげきタイプ：1
プレイヤーフラグ：true
生存フラグ：true

キャラクター名：オーク
HP：30
こうげき力：8
こうげきタイプ：1
プレイヤーフラグ：false
生存フラグ：true
```

>**キャラクター作成**を行うメソッドはどちらも**クラス外から呼び出すことは無い**ので、`private`として定義しています。**必ずしも`private`として定義する必要はありません**が、**必要最低限の範囲からしか呼び出せない**ようにすることで**バグが発生する可能性を未然に防ぐことができる**ため、非常に重要です。