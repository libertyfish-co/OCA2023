# 2 実践Rubyプログラム

## 目次
+ [RPGバトルについて](#rpgバトルについて)

<br>

---

### 進行用メソッド作成

ゲームの初期設定はほぼ完了です。次に進行していく流れを作りましょう。同じく`Game`クラスに`start`メソッドを定義してみます。一旦ゲームが始まったことがとりあえずわかるようにアナウンスします。
>`start`メソッドは外部から呼び出すので`private`ではなく`public`として定義しましょう。

`Game.new`で作成したオブジェクトを扱えるように変数`game`に入れて、`game.start()`で`start`メソッドを実行します。

```rb
# ゲームを進行するクラス
class Game
  # ゲームの初期設定を行う
  def initialize
    # 略
  end

  # ゲーム進行
  def start
    puts "\n◆◆◆ モンスターが現れた！ ◆◆◆"
  end
  
  private

  # 略

end
  
# ゲーム開始
game = Game.new
game.start()
```
```sh
↓勇者の名前を入力してください↓
リバティ # ユーザーが入力

◆◆◆ モンスターが現れた！ ◆◆◆
```

メイン部分を書く前に、事前に以下のメソッドを用意しておきましょう。内容はまだ空で構いません。

+ キャラクターのステータスを表示するメソッド  
+ 勇者のターンを処理するメソッド  
+ モンスターのターンを処理するメソッド  

```rb
# キャラクターのステータスを表示する
def show_status
  # ここに処理が入る
end

# 勇者パーティ側のターンを処理
def heroes_turn
  # ここに処理が入る
end

# モンスター側のターンを処理
def monsters_turn
  # ここに処理が入る
end
```

以下の3つで主にゲームが進行するのでそれぞれのメソッドの呼び出しを`start`メソッドに記述してみましょう。

1. ステータスを表示
1. 勇者パーティのターン
1. モンスターのターン


```rb
def start
  # 開始メッセージ
  puts "\n◆◆◆ モンスターが現れた！ ◆◆◆"
  
  # ステータス表示
  show_status()

  # 勇者のターン
  heroes_turn()

  # モンスターのターン
  monsters_turn()
end
```

#### やってみよう
`show_status`に各キャラのステータスを表示させる処理を書いてみましょう。プレビューは以下のとおりです。
```sh
・【リバティ】 HP：30 こうげき力：6
・【オーク】 HP：30 こうげき力：8
```

**※引数の使用の有無は問いません。**

<details>
<summary>コード例</summary>

```rb
# 例1
def show_status
  puts "・【#{@heroes.name}】 HP：#{@heroes.hp} こうげき力：#{@heroes.attack_damage}"
  puts "・【#{@monsters.name}】 HP：#{@monsters.hp} こうげき力：#{@monsters.attack_damage}"
end
```
```rb
# 例2 引数を使った場合

# ゲーム進行
def start 
  # 略

  # ステータス表示
  show_status(@heroes)    # 勇者パーティ表示
  show_status(@monsters)  # モンスターパーティ表示

  # 略
end

# ステータス表示
def show_status(character)
  puts "・【#{character.name}】 HP：#{character.hp} こうげき力：#{character.attack_power}"
end
```
</details>

<br>

---

### 各キャラクターの行動

勇者もモンスターもどちらもこうげきを行います。そのため、これらは共通の処理にすることができます。
`Game`クラス内にこうげき実行用の`execute_attack`メソッドを作りましょう。引数として行動をするキャラクターのオブジェクトと、こうげき対象のオブジェクトを必要とします。

```rb
# 例

# こうげき共通
def execute_attack(attacker, defender)  # (行動をするキャラクター, こうげき対象)
  # こうげきメッセージ
  puts "#{attacker.name}のこうげき！"
  
  # ダメージ処理
  damage = attacker.calculate_damage()  # ダメージ計算
  defender.receive_damage(damage)       # ダメージ反映

  puts "#{defender.name} に #{damage} のダメージ！"  # ダメージ処理
end
```

>※`calculate_damage`メソッドと`receive_damage`メソッド

こうげきにはダメージの処理が必要です。各キャラクターのステータスを握っているのは`Character`クラスなので、ダメージの詳細な処理はそこに作ります。

#### ダメージ処理を作ってみよう

ダメージを計算するメソッドとダメージをステータスに反映するメソッドを書いてみましょう。

+ `Character`クラス

  + `calculate_damage`(こうげきのダメージを計算するメソッド)
    + こうげきするキャラクターのこうげき力をダメージとして返す

  + `receive_damage`(ダメージを実際に反映するメソッド)
    + 受け取ったダメージをもとにこうげき対象のHPを引く

<details>
<summary>コード例</summary>

```rb
class Character
  # 略

  # ダメージ計算処理
  def calculate_damage
    @attack_damage  # ダメージ
  end

  # ダメージ反映処理
  def receive_damage(damage)
    @hp -= damage  # ダメージ処理
  end
end
```
</details>

---

##### こうげき力にブレ幅を持たせる
簡易的ですが、ダメージ処理の一連の処理は完成しました。  
しかし、これではダメージは一定になってしまい、ゲームとしては面白みがあまりありません。こうげき力にブレ幅を持たせてあげましょう。

+ 定数クラスにダメージのブレ幅の定数を定義し、値を`3`にする
+ ダメージが`こうげき力 ± 3`の範囲でランダムで返されるようにする

>**ヒント**:ランダムは`rand`メソッドを使うと実現できます。

<details>
<summary>コード例</summary>

```rb
# 定数管理クラス
class Constants
  # 略

  ATTACK_VARIANCE = 3  # こうげき力の触れ幅
end

# キャラクタークラス
class Character
  # 略

  # ダメージ計算処理
  def calculate_damage
    # ランダムダメージ(こうげき力±振れ幅)
    rand(@attack_damage - Constants::ATTACK_VARIANCE..@attack_damage + Constants::ATTACK_VARIANCE) 
  end

  # 略
end
```
</details>

少しずつそれっぽくなってきましたね。  

---

##### HPに最低値をもたせる
ダメージを処理を繰り返していくとそのうちHPがマイナスになってしまうので、`0`で止まるように処理を`receive_damage`に加えましょう。また、同時にこうげき対象キャラクターの生存フラグも下ろして、死滅にします。

+ 定数クラスにHPの最低値を示す定数を定義し、値を`0`にする
+ ダメージ処理後に値が`0未満`の場合は強制的に`0`にする
+ こうげき対象キャラクターの生存フラグを`false`にする

```rb
# 定数管理クラス
class Constants
  # 略

  HP_MIN = 0  # HPが最小値
end

# キャラクタークラス
class Character
  # 略

  # ダメージ反映処理
  def receive_damage(damage)
    @hp -= damage  # ダメージ処理

    # 死滅処理
    if @hp <= Constants::HP_MIN
      @hp = Constants::HP_MIN   # HPが0未満にならないよう調整 
      @is_alive = false         # 生存フラグを下ろす
    end
  end

  # 略
end
```

---

#### 各パーティの処理にこうげきメソッドを組み込もう

先ほど作った`Game`クラスの`execute_attack`メソッドを`heroes_turn`メソッドと`monsters_turn`で呼び出します。

```rb
# 勇者パーティのターン
def heroes_turn
  execute_attack(@heroes, @monsters) # (行動をするキャラクター, こうげき対象)
end

# モンスターのターン
def monsters_turn
  execute_attack(@monsters, @heroes) # (行動をするキャラクター, こうげき対象)
end
```

---

#### 逃げるメソッドを作ってみよう
ときには勇者だって逃げたくなる時もあります。そんな勇者のために`Game`クラスに逃げるメソッドを用意してあげましょう。
また、逃げる選択をした場合はゲームオーバーになるので、後ほど終了判定を作るためにフラグを用意します。

```ruby
# ゲームの初期設定
def initialize
  @escape_flg = false  # 逃げるフラグ

  # 略
end

# 略

# 逃げる
def execute_escape(character)
  puts "#{character.name}は逃げ出した！"  
  @escape_flg = true # 逃げるフラグを立てる
end
```
これで逃げ出した場合の判定フラグを用意することができました。

---

#### 勇者の行動を選択できるようにしよう
現状のコードのままだと、勇者は自動的に攻撃をするだけになります。ユーザーが入力した値を受け取って、それをもとに処理をわけてあげましょう。

+ `heroes_turn`でプレイヤーの行動の入力を受け付ける
+ `1`が入力されたらこうげきメソッドを呼び出す
+ `2`が入力されたら逃げるメソッドを呼び出し、その後`heroes_turn`メソッドをそのまま抜ける
+ 上記それぞれの値を定数にする
+ 指定した値以外が入力された場合は`無効な選択肢です。再度選んでください。`と表示し、再び入力を受け付ける

```sh
↓勇者の名前を入力してください↓
リバティ # ユーザーが入力
◆◆◆ モンスターが現れた！ ◆◆◆
・【リバティ】 HP：30 こうげき力：6
・【オーク】 HP：30 こうげき力：8

リバティ のターンです。
↓行動を選択してください↓
【1】こうげき
【2】逃げる
# ここにユーザーのコマンドが入る
```
<details>
<summary>コード例</summary>

```rb
# 定数管理クラス
class Constants
  # 略

  # 行動選択
  ACTION_ATTACK = 1  # こうげき
  ACTION_ESCAPE = 2  # 逃げる
end

# 勇者パーティのターン
def heroes_turn
  loop do
    puts "\n↓行動を選択してください↓"
    puts "【#{Constants::ACTION_ATTACK}】こうげき"
    puts "【#{Constants::ACTION_ESCAPE}】逃げる"
    choice = gets.to_i  # 行動の入力を整数で受け付ける
    
    # 行動
    case choice
    when Constants::ACTION_ATTACK
      # こうげき
      execute_attack(@heroes, @monsters) # こうげき処理
      break                              # ループを抜ける
    when Constants::ACTION_ESCAPE
      # 逃げる
      execute_attack(@heroes)            # 逃げる処理
      return         # メソッドを抜ける
    else
      # 無効な選択
      puts "無効な選択肢です"
    end
  end
end
```

>このコードでは`gets`を`to_i`で整数に変換していますが、文字列を受け取った場合は`0`として変換されてしまうことに注意が必要です。
</details>

---

#### 逃げたらゲームを終わらせよう
先ほど作った`@escape_flg`を勇者のターンのメソッド処理が終わったら確認して、もしフラグが立っていたらメソッドを抜けます。

```ruby
# ゲーム開始処理
def start
  # 略

  # 勇者パーティのターン
  heroes_turn()

  return if @escape_flg  # 逃げた場合は終了 

  # モンスターのターン
  monsters_turn()
end
```

---

### ここまでの動作を確認しよう
やや難しくなってきたところで、ここまでの動作を確認します。
うまく動作しなかった人は今一度自分のコードを振り返ってみましょう。まずは自力で挑戦して、わからないところはお手本のコードと見比べながら改善してみましょう！

```sh
↓勇者の名前を入力してください↓
リバティ # ユーザーが入力
◆◆◆ モンスターが現れた！ ◆◆◆
・【リバティ】 HP：30 こうげき力：6
・【オーク】 HP：30 こうげき力：8

↓行動を選択してください↓
【1】こうげき
【2】逃げる
1 # ユーザーが入力
リバティのこうげき！
オーク に 4 のダメージ！
オークのこうげき！
リバティ に 6 のダメージ！
```

```sh
↓勇者の名前を入力してください↓
リバティ # ユーザーが入力
◆◆◆ モンスターが現れた！ ◆◆◆
・【リバティ】 HP：30 こうげき力：6
・【オーク】 HP：30 こうげき力：8

↓行動を選択してください↓
【1】こうげき
【2】逃げる
2 # ユーザーが入力
リバティ は逃げ出した！
```

<details>
<summary>コード例</summary>

```rb
# 定数管理クラス
class Constants
  # ステータス
  HP_MIN = 0           # HP最小値
  ATTACK_VARIANCE = 3  # こうげき力のブレ幅

  # 行動選択
  ACTION_ATTACK = 1  # こうげき
  ACTION_ESCAPE = 2  # 逃げる

  # こうげきタイプ
  ATTACK_TYPE_NORMAL = 1  # 通常
  ATTACK_TYPE_MAGIC = 2   # 魔法こうげき
end
  
# キャラクタークラス
class Character
  # アクセサ
  attr_accessor :name, :hp, :attack_damage, :attack_type ,:is_player, :is_alive

  # キャラクターの初期設定を行う
  def initialize(name, hp, attack_damage, attack_type, is_player = false)
    @name = name                    # キャラクター名
    @hp = hp                        # HP
    @attack_damage = attack_damage  # こうげき力
    @attack_type = attack_type      # こうげきタイプ
    @is_player = is_player          # プレイヤーフラグ
    @is_alive = true                # 生存フラグ
  end

  # ダメージ計算処理
  def calculate_damage
    # ランダムダメージ(こうげき力±振れ幅)
    rand(@attack_damage - Constants::ATTACK_VARIANCE..@attack_damage + Constants::ATTACK_VARIANCE) 
  end

  # ダメージ反映処理
  def receive_damage(damage)
    @hp -= damage  # ダメージ処理

    # 死滅処理
    if @hp <= Constants::HP_MIN
      @hp = Constants::HP_MIN   # HPが0未満にならないよう調整 
      @is_alive = false            # 生存フラグを下ろす
    end
  end
end

# ゲームを進行するクラス
class Game
  # ゲームの初期設定を行う
  def initialize
    @escape_flg = false  # 逃げるフラグ

    puts "↓勇者の名前を入力してください↓"
    hero_name = gets.chomp  # 入力受付
    
    # キャラクターを作成
    @heroes = create_heroes(hero_name)
    @monsters = create_monsters()
  end

  # ゲーム開始処理
  def start
    # 開始メッセージ
    puts "\n◆◆◆ モンスターが現れた！ ◆◆◆"
    
    # ステータス表示
    show_status(@heroes)  # 勇者パーティ表示
    show_status(@monsters)  # モンスターパーティ表示

    # 勇者パーティのターン
    heroes_turn()

    return if @escape_flg  # 逃げた場合は終了

    # モンスターのターン
    monsters_turn()
  end
  
  private

  # 勇者パーティの作成
  def create_heroes(hero_name)
    Character.new(hero_name, 30, 6, Constants::ATTACK_TYPE_NORMAL, true)  # プレイヤーが操作する勇者
  end

  # モンスターパーティの作成
  def create_monsters
    Character.new('オーク', 30, 8, Constants::ATTACK_TYPE_NORMAL)   # オーク(CPU)
  end

  # こうげき共通
  def execute_attack(attacker, defender)  # (行動をするキャラクター, こうげき対象)
    # こうげきメッセージ
    puts "#{attacker.name}のこうげき！"
    
    # ダメージ処理
    damage = attacker.calculate_damage()  # ダメージ計算
    defender.receive_damage(damage)       # ダメージ反映

    puts "#{defender.name} に #{damage} のダメージ！"  # ダメージ処理
  end

  # 逃げる
  def execute_escape(character)
    puts "#{character.name}は逃げ出した！"  
    @escape_flg = true # 逃げるフラグを立てる
  end

  # ステータス表示
  def show_status(character)
    puts "・【#{character.name}】 HP：#{character.hp} こうげき力：#{character.attack_damage}"
  end

  # 勇者パーティのターン
  def heroes_turn
    loop do
      puts "\n↓行動を選択してください↓"
      puts "【#{Constants::ACTION_ATTACK}】こうげき"
      puts "【#{Constants::ACTION_ESCAPE}】逃げる"
      choice = gets.to_i  # 行動の入力を整数で受け付ける
    
      # 行動
      case choice
      when Constants::ACTION_ATTACK
        # こうげき
        execute_attack(@heroes, @monsters) # こうげき処理
        break                 # ループを抜ける
      when Constants::ACTION_ESCAPE
        # 逃げる
        execute_escape(@heroes)   # 逃げる処理
        return  # メソッドを抜ける
      else
        # 無効な選択
        puts "無効な選択肢です"
      end
    end
  end
  
  # モンスターのターン
  def monsters_turn
    execute_attack(@monsters, @heroes) # (行動をするキャラクター, こうげき対象)
  end
end
  
# ゲーム開始
gm = Game.new
gm.start()
```
</details>