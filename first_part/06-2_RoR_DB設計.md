## 6.3 Ruby on Rails：データベース設計

ここからは、サイトアプリケーションの開発を例に各実装を解説していきます。
まず、この章では、メモアプリを例にのデータベース設計の解説を行います。
設計のために、データベース設計の基礎、多対多の関連付けについて簡単に説明します。

## データベース設計とは

データベースは、アプリケーションを動作させる上で重要な役割を担っています。  
アプリケーションを開発する際には、「どのデータをどのように保存するか」を事前に設計しておかなければ、以下のような問題が発生する可能性があります:
- 複雑なデータ処理が必要になる
- 必要な機能が実現できない
- データベースを一から作り直す必要が生じる

例えば、データベース設計を家の設計に例えるとわかりやすいでしょう。  
家を建てる際、間取りや設備の配置を考えずに建築を始めると、後から水道や電気の配線をやり直す必要が出てくるかもしれません。さらに、窓の位置やドアの配置が不適切で、住み心地が悪くなることも考えられます。  
同様に、データベース設計を怠ると、後々の機能追加や修正に大きなコストがかかり、アプリケーションの使い勝手にも影響を及ぼします。

そのため、開発の初期段階で必要なデータを明らかにし、どのような形で保存するかを検討して設計することが重要です。  
このように、事前にデータベースの詳細な構造を計画する作業を「データベース設計（database design）」と呼びます。

データベース設計は、アプリケーションの土台を構築する重要なプロセスであり、効率的なデータ管理やパフォーマンス向上に直結します。

## データベース設計を行う

それでは、実際にデータベース設計のプロセスを見ていきましょう。

今回は、「メモアプリ」を例にして、データベース設計の手順をご紹介します。以下の手順に従って設計を進めていきます。

### データベース設計の手順

1. **必要なデータ項目をまとめる**: 各画面で必要な情報をリストアップします。
2. **カラム名を決める**: データ項目に対応するカラム名を決定します。
3. **「列の繰り返し項目」を削除する**: 同じ種類のデータが複数列に分かれる場合、それらを1つの列に統合します。
4. **「行の繰り返し項目」を削除する**: 繰り返しデータが複数行に分かれる場合、別のテーブルに分割して管理します。
5. **テーブルにIDカラムを追加する**: 各テーブルに一意の識別子（IDカラム）を設けます。
6. **共通利用のデータをテーブル化する**: 他のテーブルで共通して使用されるデータを独立したテーブルにまとめます。
7. **テーブルの構造を考える**: テーブル間の関係性や参照方法を設計します。

## データベースの基本構成

データベースは、「テーブル」と「カラム」で構成されています。
データベース設計では、まず、「どのようなテーブルが必要になるか」を考えることが出発点です。

例えば、「メモアプリ」では、以下のようなテーブルが必要になるかもしれません:
- ユーザー情報を保存するテーブル
- 投稿内容を保存するテーブル
- コメントやレビューを保存するテーブル

### テーブル間の関係性
テーブルは、アプリケーション内でデータの関連性を持っています。  
例えば、以下のような関係性が考えられます:
- **ユーザーと投稿**: ユーザーが投稿を作成する（一対多の関係）。
- **投稿とコメント**: 各投稿に複数のコメントが付く（一対多の関係）。
- **投稿と飲食店情報**: 各投稿が特定の飲食店に紐付く（一対一または一対多の関係）。

これらの関係性を明確にすることで、テーブル設計がスムーズに進みます。

## データベース設計の重要性

適切なデータベース設計は、以下のメリットをもたらします:
- **データの一貫性と正確性の向上**: データの重複や矛盾を防ぐ。
- **メンテナンスの容易さ**: テーブル構造が整理されているため、変更が容易。
- **アプリケーションパフォーマンスの向上**: 効率的なデータ取得が可能。


## 繰り返し項目を削除する

### 正規化
正規化（Normalization）は、リレーショナルデータベース（RDBMS）において、データの構造を最適化し、データの冗長性を排除するための手法です。これにより、データの更新異常を防ぎ、データの整合性を保つことができます。以下では、正規化のプロセスを詳しく説明します。

正規化の目的
正規化の主な目的は次の2つです。

- **データの冗長性を排除する**  
重複したデータが存在することで、データの管理が複雑になります。正規化により、冗長なデータを減らし、効率的なデータの管理が可能になります。

- **データの更新異常を防ぎ、整合性を保つ**    
更新異常とは、データを変更する際に不整合が生じることです。正規化により、データの更新時に不整合が発生しないようにします。

## 正規化のプロセス

### 第1正規化（1NF）
- **目的**: 繰り返し項目を排除し、各セルに単一の値を格納。
- **例**: 一つの行に複数の値を持つ「タグ」カラムを別テーブルに分割。

### 第2正規化（2NF）
- **目的**: 主キーの一部にのみ依存する属性を分離。
- **例**: 「カテゴリ名」を「カテゴリID」として別のカテゴリテーブルで管理。

### 第3正規化（3NF）
- **目的**: 推移的関数従属を排除。
- **例**: 「ユーザー名」を「ユーザーID」で管理し、ユーザーテーブルを分離。

### 第4正規化・第5正規化
さらに複雑な整合性を確保。ただし、実務では第3正規化までで十分な場合が多いです。


第1正規化（1NF）
第1正規化では、「繰り返し項目」が存在しないことが求められます。繰り返し項目とは、複数の値を一つのフィールドに格納するようなデータ構造を指します。
## ステップ 1: 初期設計 (非正規形)

以下のような非正規形のテーブルを考えます。

### メモテーブル (非正規形)
| メモID | ユーザー名 | メモ内容     | 作成日     | カテゴリ名   | タグ         |
| ------ | ---------- | ------------ | ---------- | ------------ | ------------ |
| 1      | 山田太郎   | 会議の議事録 | 2025/01/01 | 仕事         | 会議, 議事録 |
| 2      | 鈴木花子   | 買い物リスト | 2025/01/02 | プライベート | 買い物, 食品 |
| 3      | 山田太郎   | 旅行計画     | 2025/01/03 | プライベート | 旅行, 予定   |

ここでは「タグ」カラムが複数の値を持っており、非正規形になっています。

---
例:
メモテーブルで、1つの行に複数のタグが記録されている場合、タグが繰り返し項目になります。このような構造は、第1正規化を満たしていません。

解決策:
繰り返し項目を別のテーブルとして分割し、関係性を明示的に定義します。例えば、「タグテーブル」を作成し、各メモとタグを個別に管理します。

## ステップ 2: 第1正規形 (繰り返し項目の排除)

「タグ」カラムに繰り返し項目が含まれているため、これを分割して別のテーブルに移動します。

### メモテーブル
| メモID | ユーザー名 | メモ内容     | 作成日     | カテゴリ名   |
| ------ | ---------- | ------------ | ---------- | ------------ |
| 1      | 山田太郎   | 会議の議事録 | 2025/01/01 | 仕事         |
| 2      | 鈴木花子   | 買い物リスト | 2025/01/02 | プライベート |
| 3      | 山田太郎   | 旅行計画     | 2025/01/03 | プライベート |

### タグテーブル
| タグID | メモID | タグ名 |
| ------ | ------ | ------ |
| 1      | 1      | 会議   |
| 2      | 1      | 議事録 |
| 3      | 2      | 買い物 |
| 4      | 2      | 食品   |
| 5      | 3      | 旅行   |
| 6      | 3      | 予定   |

これにより、「タグ」が複数値を保持する問題を解消しました。


## ステップ 3: 第2正規形 (部分関数従属の排除)
第2正規化（2NF）
第2正規化は、第1正規化を満たした上で、すべての非キー属性が主キーに対して完全関数従属していることを要求します。


非正規形から第1正規形の段階まで  
第1正規化により、繰り返し項目を排除し、メモとタグを別のテーブルに分割しました。

第2正規化では、主キーの一部に依存する非キー属性を別テーブルに移動することで、データの冗長性を排除します。


### 例：メモテーブルにおける部分関数従属の排除
メモテーブルでは、以下の構造に部分関数従属の問題が存在します：
- 「カテゴリ名」は「メモID」に依存しており、「カテゴリ」に関する情報が重複する可能性があります。


主キーの一部に依存する非キー属性を別テーブルに移動します。この例では、「カテゴリ名」が「メモID」に依存していますが、カテゴリをマスタテーブルとして分けることで対応します。

### メモテーブル
| メモID | ユーザー名 | メモ内容     | 作成日     | カテゴリID |
| ------ | ---------- | ------------ | ---------- | ---------- |
| 1      | 山田太郎   | 会議の議事録 | 2025/01/01 | 1          |
| 2      | 鈴木花子   | 買い物リスト | 2025/01/02 | 2          |
| 3      | 山田太郎   | 旅行計画     | 2025/01/03 | 2          |

### カテゴリテーブル
| カテゴリID | カテゴリ名   |
| ---------- | ------------ |
| 1          | 仕事         |
| 2          | プライベート |

---
## ステップ 4: 第3正規形 (推移的関数従属の排除)

第3正規化（3NF）
第3正規化では、推移的関数従属を排除します。推移的関数従属とは、あるフィールドが他のフィールドに間接的に依存している場合を指します。

例:
貸出テーブルにおいて、貸出番号が決まると利用者コードが決まり、さらに利用者コードが決まると利用者名が決まるという依存関係が存在します。このような推移的関数従属を解消するために、利用者マスターテーブルを作成し、利用者コードと利用者名を分離します。


推移的関数従属を排除するため、ユーザー情報を別テーブルに移動します。

### メモテーブル
| メモID | ユーザーID | メモ内容     | 作成日     | カテゴリID |
| ------ | ---------- | ------------ | ---------- | ---------- |
| 1      | 1          | 会議の議事録 | 2025/01/01 | 1          |
| 2      | 2          | 買い物リスト | 2025/01/02 | 2          |
| 3      | 1          | 旅行計画     | 2025/01/03 | 2          |

### ユーザーテーブル
| ユーザーID | ユーザー名 |
| ---------- | ---------- |
| 1          | 山田太郎   |
| 2          | 鈴木花子   |

### カテゴリテーブル
| カテゴリID | カテゴリ名   |
| ---------- | ------------ |
| 1          | 仕事         |
| 2          | プライベート |

### タグテーブル
| タグID | メモID | タグ名 |
| ------ | ------ | ------ |
| 1      | 1      | 会議   |
| 2      | 1      | 議事録 |
| 3      | 2      | 買い物 |
| 4      | 2      | 食品   |
| 5      | 3      | 旅行   |
| 6      | 3      | 予定   |

---

第4正規化（4NF）および第5正規化（5NF）
第4正規化および第5正規化では、さらに複雑なデータの整合性を確保しますが、実際には第3正規化まで行えば多くの場合十分です。


このように、正規化を行うことで、データの一貫性を保ちつつ、冗長性を削減することができます。

# メモアプリのデータベース設計

メモアプリでは、ユーザーが複数のメモを持ち、それぞれのメモにはカテゴリやタグを設定できるとします。また、メモの内容や作成日なども記録します。


## 最終形のデータベース設計  

## データ型を決める  

まず、データ型について簡単に説明します。データ型は、データベースにどのようなデータを保存するかを決める重要な要素です。以下は主なデータ型の例です。

1. **文字列型 (String)**: 名前やタイトルなどの短い文字列を保存します。  
   例: ユーザー名やカテゴリ名  
   - データベースの型: `string`
2. **整数型 (Integer)**: 数字を保存します。  
   例: IDや数量  
   - データベースの型: `integer`
3. **日付型 (Date/Datetime)**: 日付や日時を保存します。  
   例: メモの作成日  
   - データベースの型: `date` または `datetime`
4. **テキスト型 (Text)**: 長い文章を保存します。  
   例: メモの内容  
   - データベースの型: `text`
5. **真偽値型 (Boolean)**: 「はい」か「いいえ」のデータを保存します。  
   例: タスクが完了したかどうか  
   - データベースの型: `boolean`

---

## フィールド名を決める  

データベースのフィールド名（列名）は、データの内容がわかりやすいように名前を付けます。一般的に **スネークケース**（単語の間をアンダースコア _ で区切る）を使います。

---

## メモアプリのデータベース設計  

以下は、メモアプリのデータベースを設計した例です。

### 1. メモテーブル  
メモの基本情報を保存するテーブルです。  

| フィールド名       | データ型   | 意味                | 備考         |
| ------------------ | ---------- | ------------------- | ------------ |
| `memo_id`          | Integer    | メモの識別ID        | 主キー        |
| `user_name`        | String     | ユーザー名          |              |
| `memo_content`     | Text       | メモの内容          |              |
| `created_at`       | Datetime   | メモの作成日時      | 自動生成可能 |
| `category_id`      | Integer    | カテゴリの識別ID    | 外部キー      |

---

### 2. カテゴリテーブル  
メモに関連付けられるカテゴリを保存するテーブルです。

| フィールド名       | データ型   | 意味                | 備考         |
| ------------------ | ---------- | ------------------- | ------------ |
| `category_id`      | Integer    | カテゴリの識別ID    | 主キー        |
| `category_name`    | String     | カテゴリ名          |              |

---

### 3. タグテーブル  
メモに設定されるタグを保存するテーブルです。

| フィールド名       | データ型   | 意味                | 備考         |
| ------------------ | ---------- | ------------------- | ------------ |
| `tag_id`           | Integer    | タグの識別ID        | 主キー        |
| `memo_id`          | Integer    | メモの識別ID        | 外部キー      |
| `tag_name`         | String     | タグ名              |              |

---

### テーブルのデータ例  

#### メモテーブル  
| memo_id | user_name | memo_content | created_at       | category_id |
| ------- | --------- | ------------ | ---------------- | ----------- |
| 1       | 山田太郎  | 会議の議事録  | 2025-01-01 10:00 | 1           |
| 2       | 鈴木花子  | 買い物リスト  | 2025-01-02 14:30 | 2           |
| 3       | 山田太郎  | 旅行計画      | 2025-01-03 09:15 | 2           |

#### カテゴリテーブル  
| category_id | category_name |
| ----------- | ------------- |
| 1           | 仕事          |
| 2           | プライベート  |

#### タグテーブル  
| tag_id | memo_id | tag_name  |
| ------ | ------- | --------- |
| 1      | 1       | 会議      |
| 2      | 1       | 議事録    |
| 3      | 2       | 買い物    |
| 4      | 2       | 食品      |
| 5      | 3       | 旅行      |
| 6      | 3       | 計画      |

---

## ポイント  
1. **使いやすい名前を考える**  
   フィールド名やテーブル名は、データの意味が直感的にわかるようにします。  
2. **スネークケースを使う**  
   名前の統一感を持たせ、コードが読みやすくなります。  
3. **データの関係性を明確にする**  
   「メモ」と「カテゴリ」や「タグ」のように、関連するデータは外部キーを使って結びつけます。

---
