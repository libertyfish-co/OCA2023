<details open>
<summary>仮置き、コード全容</summary>

```ruby
class Constants
  # 定数管理クラス

  # HPが0の定義
  HP_ZERO = 0.freeze
  # 攻撃力のブレ幅
  ATTACK_VARIATION = 3.freeze

  # 行動選択：攻撃
  CHOICE_ATTACK = 1.freeze
  # 行動選択：逃げる
  CHOICE_ESCAPE = 2.freeze

  # 攻撃タイプ：通常
  ATTACK_TYPE_NORMAL = 1.freeze
  # 攻撃タイプ：魔法攻撃
  ATTACK_TYPE_MAGIC = 2.freeze
  
  # 書き出し間隔
  LOG_INTERVAL = 1.freeze
end

class Message
  # 各種表示メッセージを管理するクラス

  # 名前の入力をユーザーに求める
  def self.enter_name
    "勇者の名前を入力してください:"
  end

  # ターン数表示
  def self.game_turn(turn)
    "=== ターン #{turn} ==="
  end

  # キャラクターのステータスを表示
  def self.status(character)
    dead_marker = !character.alive? ? "×" : "・"   # 死滅している場合につけるマーカー
    "#{dead_marker}#{character.name}: HP=#{character.hp} 攻撃力=#{character.attack_power}"
  end

  # 操作メッセージ
  def self.action_choice(hero)
    "#{hero.name}のターンです。\n#{Constants::CHOICE_ATTACK}: 攻撃 #{Constants::CHOICE_ESCAPE}: 逃げる"
  end

  # 無効な選択肢が入力された際のメッセージ
  def self.invalid_choice
    "無効な選択肢です。再度選んでください。"
  end

  # 攻撃のメッセージ
  def self.attack(attacker)
    case attacker.attack_type
    when Constants::ATTACK_TYPE_NORMAL
      message = "#{attacker.name}のこうげき！"
    when Constants::ATTACK_TYPE_MAGIC
      message = "#{attacker.name}は呪文を唱えた！"
    end
    message
  end

  # ダメージ
  def self.damage(target, damage)
    "#{target.name}に#{damage}のダメージ！"
  end

  # キャラクター死滅
  def self.death(target)
    "#{target.name}は死滅した！"
  end

  # 勇者が逃げた際のメッセージを表示し、ゲームオーバーを宣言
  def self.escape(hero)
    "#{hero.name}は逃げ出した！"
  end

  # 勝敗結果
  def self.winner(hero_alive)
    hero_alive ? "勇者パーティの勝利！" : "勇者たちは力尽きてしまった！"
  end

  # ゲームオーバーの表記
  def self.game_over
    "GAME OVER!!!"
  end
end

class Character
  # キャラクタークラス

  # アクセサ
  attr_accessor :name, :hp, :attack_power, :attack_type ,:player

  # キャラクターの初期設定を行う
  def initialize(name, hp, attack_power, attack_type, player = false)
    @name = name                  # キャラクター名
    @hp = hp                      # HP
    @attack_power = attack_power  # 攻撃力
    @attack_type = attack_type    # 攻撃タイプ
    @player = player              # プレイヤーフラグ
  end

  # キャラクターが生存しているかを判定
  def alive?
    @hp > Constants::HP_ZERO    # HPが0以上ならtrueを返す
  end

  # 攻撃のダメージ処理
  def attack(target)
    # 攻撃力の範囲をランダムに決定(ステータスの攻撃力±振れ幅)
    damage = rand(@attack_power - Constants::ATTACK_VARIATION..@attack_power + Constants::ATTACK_VARIATION)
    target.take_damage(damage)  # 対象キャラクターにダメージを与える
    damage
  end

  # ダメージ適用処理
  def take_damage(damage)
    @hp -= damage   # ダメージ処理
    @hp = Constants::HP_ZERO if @hp < Constants::HP_ZERO # HPが0未満にならないよう調整
  end

end

class Game
  # ゲーム進行クラス

  # ゲームの初期設定を行う
  def initialize
    # プレイヤーに勇者の名前を入力させる
    show_message(Message.enter_name)        # メッセージ表示
    hero_name = gets.chomp    # 入力受付
    
    # キャラクターの作成(キャラ名, HP, 攻撃力, 攻撃タイプ, プレイヤーフラグ) 
    @heroes = [
      Character.new(hero_name, 30, 6, Constants::ATTACK_TYPE_NORMAL, true),  # プレイヤーが操作する勇者
      Character.new('魔法使い', 20, 8, Constants::ATTACK_TYPE_MAGIC)          # 魔法使い(CPU)
    ]
    @monsters = [
      Character.new('オーク', 30, 8, Constants::ATTACK_TYPE_NORMAL),   # オーク(CPU)
      Character.new('ゴブリン', 25, 6, Constants::ATTACK_TYPE_NORMAL)  # ゴブリン(CPU)
    ]
  end

  # ゲーム開始処理
  def start
    turn = 0    # ターン数

    # 全滅パーティが発生するまでループ
    while @heroes.any?(&:alive?) && @monsters.any?(&:alive?)
      turn += 1
      show_message(Message.game_turn(turn))           # ターン数表示
      show_status                                     # 現在のステータスを表示
      attack_hero_turn if @heroes.any?(&:alive?)      # 勇者側のターン
      break if game_over?                             # ゲームオーバー判定
      attack_monster_turn if @monsters.any?(&:alive?) # モンスター側のターン
      break if game_over?                             # ゲームオーバー判定
    end

    # 勝敗結果のメッセージを表示
    show_message(Message.winner(@heroes.any?(&:alive?)))  
  end

  private

  # メッセージ表示(文字列, 待機時間の有無)
  def show_message(message, wait = false)
    puts message
    sleep Constants::LOG_INTERVAL if wait
  end
  
  # キャラクターのステータスを表示するメソッド
  def show_status
    # 勇者パーティとモンスターそれぞれのステータスを表示
    @heroes.each { |hero| show_message(Message.status(hero)) }
    @monsters.each { |monster| show_message(Message.status(monster)) }
  end

  # 勇者パーティ側のターンを処理
  def attack_hero_turn
    
    @heroes.each do |hero|
      next unless hero.alive?   # 死滅キャラはスキップ
      loop do
        if hero.player
          show_message(Message.action_choice(hero)) # 選択メッセージ
          choice = gets.to_i          # 入力受付
        else
          # 味方の行動設定
          choice = Constants::CHOICE_ATTACK      # 攻撃
        end

        case choice
        when Constants::CHOICE_ATTACK
          # 攻撃を選択
          attack_target = @monsters.select(&:alive?).sample                       # 攻撃対象を指定
          if attack_target                                                        # ターゲットが存在する場合は攻撃
            show_message(Message.attack(hero), true)                              # 攻撃メッセージを表示
            damage = hero.attack(attack_target)                                   # ダメージ決定
            show_message(Message.damage(attack_target, damage), true)             # ダメージ表示
            show_message(Message.death(attack_target)) if !attack_target.alive?   # HPが0になったら死滅メッセージを表示
          end
          break
        when Constants::CHOICE_ESCAPE
          # 逃げるを選択
          show_message(Message.escape(hero), true)  # 逃げる処理
          show_message(Message.game_over())         # ゲームオーバーの表示
          game_end()                                # ゲームを終わらせる
        else 
          # 無効な選択肢
          show_message(Message.invalid_choice)  # エラーメッセージ
        end
      end
    end
  end

  # モンスター側のターンを処理
  def attack_monster_turn
    @monsters.each do |monster|
      next unless monster.alive?  # 生存しているモンスターのターンのみ

      # 勇者のいずれかをターゲットにして攻撃
      attack_target = @heroes.select(&:alive?).sample
      if attack_target
        show_message(Message.attack(monster), true)                                 # 行動メッセージ
        damage = monster.attack(attack_target)                                      # ダメージ計算
        show_message(Message.damage(attack_target, damage), true)                   # ダメージ表示
        show_message(Message.death(attack_target), true) if !attack_target.alive?   # HPが0になったら死滅メッセージを表示
      end
    end
  end

  # ゲームオーバー判定
  def game_over?
    # どちらかのパーティが全滅した場合にtureを返す
    !@heroes.any?(&:alive?) || !@monsters.any?(&:alive?)
  end

  # ゲーム終了
  def game_end
    exit
  end
end

# ゲーム開始
game = Game.new
game.start

```
</details>







# 2 実践Rubyプログラム：RPGバトルを作ろう！

## 目次
+ [RPGバトルを作ろう](#rpgバトルを作ろう)

<br>

---

## RPGバトルを作ろう

このテキストでは、Rubyを使ってシンプルなRPGバトルを実装します。ターン制バトルを作りながら、Rubyの基本的な構文や概念を復習します。

### ゲームの目的

このゲームの目的は、プレイヤー（勇者）とコンピューター操作のモンスターが戦うターン制バトルを実装することです。プレイヤーは攻撃や魔法を使ってモンスターを倒し、勝利を目指します。

+ **完成イメージ（例）**

  ```sh
  勇者の名前を入力してください:リバティ

  === ターン 1 ===
  
  ```

  <details>
  <summary>もっと見る</summary>

  ```sh
  勇者の名前を入力してください:リバティ

  === ターン 1 ===
  リバティ: HP=30 Attack=6
  魔術師: HP=20 Attack=8
  オーク: HP=30 Attack=8
  ゴブリン: HP=25 Attack=6
  リバティのターンです。
  1: 攻撃 2: 逃げる
  1
  リバティの攻撃！オークに5のダメージ！
  魔術師の魔法攻撃！オークに9のダメージ！
  オークの攻撃！リバティに11のダメージ！
  ゴブリンの攻撃！リバティに8のダメージ！

  === ターン 2 ===
  リバティ: HP=11 Attack=6
  魔術師: HP=20 Attack=8
  オーク: HP=16 Attack=8
  ゴブリン: HP=25 Attack=6
  リバティのターンです。
  1: 攻撃 2: 逃げる
  1
  リバティの攻撃！オークに5のダメージ！
  魔術師の魔法攻撃！オークに10のダメージ！
  オークの攻撃！リバティに8のダメージ！
  ゴブリンの攻撃！リバティに5のダメージ！
  リバティは死滅した！
  
  ...

  === ターン 6 ===
  ✕リバティ: HP=0 Attack=6
  魔術師: HP=2 Attack=8
  ✕オーク: HP=0 Attack=8
  ゴブリン: HP=7 Attack=6
  魔術師の魔法攻撃！ゴブリンに9のダメージ！
  ゴブリンは死滅した！
  勇者パーティの勝利！
  ```
  
  ```sh
  勇者の名前を入力してください:リバティ

  === ターン 1 ===
  リバティ: HP=30 Attack=6
  魔術師: HP=20 Attack=8
  オーク: HP=30 Attack=8
  ゴブリン: HP=25 Attack=6
  リバティのターンです。
  1: 攻撃 2: 逃げる
  1
  リバティの攻撃！オークに4のダメージ！
  魔術師の魔法攻撃！オークに11のダメージ！
  オークの攻撃！リバティに5のダメージ！
  ゴブリンの攻撃！リバティに7のダメージ！

  === ターン 2 ===
  リバティ: HP=18 Attack=6
  魔術師: HP=20 Attack=8
  オーク: HP=15 Attack=8
  ゴブリン: HP=25 Attack=6
  リバティのターンです。
  1: 攻撃 2: 逃げる
  2
  リバティは逃げ出した！
  GAME OVER
  ```

  </summary>

---

### ゲームの流れ
プログラミングをする際には、まずゲームの流れを把握することが重要です。以下のフローチャートは、その流れを簡潔に示したものです。

<img src="images/実践Rubyプログラム/フロー.png" width="500px">

プログラムの流れを理解した上でコーディングを進めることは、非常に効果的です。流れを整理することで、よりスムーズにプログラミングを進めることができます。  

また、プログラムの構成を考えることも大切です。例えば、どのようなクラスを作成するか、どんなメソッドを用意するかなど、正解は一つではありません。このテキストではお手本のコードに沿っていきますが、自分なりに最適な設計を考えてみてもいいかもしれません。  

---

### まずGameクラス

---

### キャラクターを作ろう

ゲームに登場するキャラクター、たとえば**勇者**や**モンスター**をどうやって表現するか考えてみましょう。ゲームの中でキャラクターに共通する要素は何でしょうか？

+ **例**
  + 名前（**誰**なのか）  
  + HP（**体力**、戦闘で生き残るために必要）  
  + 攻撃力（**どれだけ強く攻撃できるか**）  

これらの共通点があることで、キャラクターをひとつのオブジェクトとして扱いやすくなります。この共通の要素を使って、実際にキャラクターを作るためのクラスを作成してみましょう！  

---

# 以下編集中

---

## 1. メッセージを表示するクラス  
ゲーム中に表示するメッセージを管理するために、`Message`クラスを作成します。攻撃や魔法攻撃のメッセージ、ゲームオーバーのメッセージなどを管理します。

### `Message`クラスの実装

```ruby
class Message
  def self.attack(attacker, target, damage)
    puts "#{attacker.name}の攻撃！#{target.name}に#{damage}のダメージ！"
  end

  def self.death(target)
    puts "#{target.name}は死滅した！"
  end
end
```

---

## 4. ターン制バトルを実装しよう

次に、ゲームの流れを作ります。ターンごとにプレイヤー（勇者）とモンスターが交互に行動します。

### ゲームの進行

```ruby
class Game
  def initialize
    @heroes = [
      Character.new('勇者', 30, 6),  # プレイヤーキャラクター
      Character.new('魔術師', 20, 8) # CPUキャラクター
    ]
    @monsters = [
      Character.new('オーク', 30, 8), # モンスターキャラクター
      Character.new('ゴブリン', 25, 6)
    ]
  end

  def start
    turn = 0
    while @heroes.any?(&:alive?) && @monsters.any?(&:alive?)
      turn += 1
      puts "
=== ターン #{turn} ==="
      show_status  # ステータスの表示
      hero_turn if @heroes.any?(&:alive?) # 勇者のターン
      break if game_over? # ゲームオーバー判定
      monster_turn if @monsters.any?(&:alive?) # モンスターのターン
      break if game_over? # ゲームオーバー判定
    end
    winner
  end

  private

  def show_status
    @heroes.each { |hero| puts hero.status }
    @monsters.each { |monster| puts monster.status }
  end

  def hero_turn
    @heroes.each do |hero|
      next unless hero.alive?

      puts "#{hero.name}のターンです。"
      hero.attack(@monsters.first)
    end
  end

  def monster_turn
    @monsters.each do |monster|
      next unless monster.alive?

      monster.attack(@heroes.first)
    end
  end

  def game_over?
    !@heroes.any?(&:alive?) || !@monsters.any?(&:alive?)
  end

  def winner
    if @heroes.any?(&:alive?)
      puts "勇者パーティの勝利！"
    else
      puts "GAME OVER"
    end
  end
end

# ゲーム開始
game = Game.new
game.start
```

このコードでは、ゲームのターン制バトルを作成しました。`hero_turn`と`monster_turn`で勇者とモンスターが交互に攻撃し、ゲームが進行します。

---

## 5. ユーザー入力の処理（選択肢の入力）

ゲームにユーザーの入力を組み込むことで、プレイヤーが攻撃するか逃げるか選べるようにします。これにより、よりインタラクティブなゲームになります。

### 攻撃と逃げる選択肢

```ruby
def player_turn
  loop do
    puts "1: 攻撃 2: 逃げる"
    choice = gets.chomp.to_i

    case choice
    when 1
      @heroes.first.attack(@monsters.first)
      break
    when 2
      puts "勇者は逃げた！"
      exit
    else
      puts "無効な選択肢です。再度選んでください。"
    end
  end
end
```

---

## 6. ゲームオーバーと勝利判定

ゲームの進行中に、キャラクターが死亡した場合や全滅した場合の処理を追加します。

### 勝利判定とゲームオーバー

```ruby
def winner
  if @heroes.any?(&:alive?)
    puts "勇者パーティの勝利！"
  else
    puts "GAME OVER"
  end
end
```

---

## 7. まとめと次のステップ

ここまでで、基本的なRPGバトルのゲームが完成しました。次のステップとして、以下のような追加機能を考えてみると面白いでしょう：
- アイテムシステムの追加（回復アイテム、強化アイテム）
- キャラクターのレベルアップシステム
- 戦闘のエフェクト（アニメーションや音声の追加）

---

このテキストを通じて、Rubyの基本的な構文を復習しながら、簡単なRPGバトルゲームを作成することができました。次のステップでは、さらに複雑な機能を追加して、ゲームをもっと面白くしていきましょう！
