# 2 実践Rubyプログラム

## 目次

+ [作ってみよう](#作ってみよう)
    + [シンプルな計算プログラム](#シンプルな計算プログラム)
    + [ショッピングカートの合計計算](#ショッピングカートの合計計算)
    + [顧客情報の登録プログラム](#顧客情報の登録プログラム)
    + [ビンゴカード作成プログラム](#ビンゴカード作成プログラム)

## 作ってみよう

より実践的なプログラミングの題材を用意しました。プログラムの**要件**と**期待する出力例**をもとに、フローを考えたり、必要なメソッドなライブラリ調べながら進めてみましょう！

### シンプルな計算プログラム

#### **プログラムの要件**  
- ユーザーから2つの整数を入力として受け取る  
- それらの和、差、積、商を計算する  
- 計算結果を見やすい形式で出力する  
- 商は整数で表示する（小数点以下切り捨て）

#### **期待する出力例**
```sh
1つ目の数字を入力してください: 10
2つ目の数字を入力してください: 3
和: 13
差: 7
積: 30
商: 3
```

<details>
<summary>コード例・解説</summary>

```ruby
print "1つ目の数字を入力してください: "
num1 = gets.to_i

print "2つ目の数字を入力してください: "
num2 = gets.to_i

puts "和: #{num1 + num2}"
puts "差: #{num1 - num2}"
puts "積: #{num1 * num2}"
puts "商: #{num1 / num2}"
```

このプログラムでは、ユーザーから2つの整数を入力として受け取り、それらの基本的な四則演算（加算、減算、乗算、除算）を行います。

1. **入力の取得**
    ```ruby
    print "1つ目の数字を入力してください: "
    num1 = gets.to_i
    ```
    - `print` を使ってユーザーに入力を求めます。
    - `gets` で入力を取得し、`.to_i` を使って整数に変換します（`gets` の戻り値は文字列なので、数値計算のために変換が必要）。

1. **演算の実行**
    ```ruby
    puts "和: #{num1 + num2}"
    puts "差: #{num1 - num2}"
    puts "積: #{num1 * num2}"
    puts "商: #{num1 / num2}"
    ```
    - `+` は加算、`-` は減算、`*` は乗算、`/` は除算を行います。
    - `#{}` を使うことで、文字列の中に計算結果を埋め込むことができます。
    - `/` 演算子を使うと整数同士の割り算になるため、小数点以下は自動的に切り捨てられます。

#### 発展
要件には含まれていませんが、現在のプログラムでは2つ目の数値 `num2` が0のとき、除算（`num1 / num2`）でエラーが発生します。  
これを防ぐために、除算の前にゼロチェックを行うのも良い改善点です。

```ruby
if num2 != 0
  puts "商: #{num1 / num2}"
else
  puts "0で割ることはできません"
end
```

</details>

<br>

---

### ショッピングカートの合計計算

#### **プログラムの要件**  
- ユーザーから5つの商品価格を入力として受け取り、それらを配列に格納する。  
- その配列を使って、以下の計算を行う  
    - 価格の合計
    - 価格の平均
    - 最安値
    - 最高値
- 計算結果を見やすい形式で出力する  
- 商は整数で表示する（小数点以下切り捨て）

#### **期待する出力例**
```sh
商品価格を5つ入力してください:

1つ目の価格: 1500
2つ目の価格: 2000
3つ目の価格: 500
4つ目の価格: 1200
5つ目の価格: 800

合計金額: 6000
平均金額: 1200.0
最安値: 500
最高値: 2000
```

<details>
<summary>コード例・解説</summary>

```ruby
# ユーザーに入力を促す
print "商品価格を5つ入力してください: \n\n"

# 商品価格を格納する配列
prices = []

# 5つの商品価格を入力してもらう
5.times do |i|
  print "#{i + 1}つ目の価格: "
  price = gets.to_i  # 入力された価格を整数として取得
  prices << price  # 配列に追加
end

# 合計金額を計算
total_price = prices.sum

# 平均金額を計算
average_price = total_price.to_f / prices.size

# 最安値と最高値を計算
min_price = prices.min
max_price = prices.max

# 結果を表示
puts "\n合計金額: #{total_price}"
puts "平均金額: #{average_price}"
puts "最安値: #{min_price}"
puts "最高値: #{max_price}"
```

</details>

<br>

---

### 顧客情報の登録プログラム

#### **要件**  
- ユーザーに名前、年齢、住所、電話番号を順番に入力として受け取る
- それらの情報をハッシュ（辞書型）に格納する
- 入力された情報を整形して「顧客情報」として表示する

#### **期待する出力例**
```sh
名前を入力してください: リバティ 太郎
年齢を入力してください: 21
住所を入力してください: 大阪府大阪市中央区
電話番号を入力してください: 06-XXXX-XXXX

顧客情報:
名前: リバティ 太郎
年齢: 21
住所: 大阪府大阪市中央区
電話番号: 06-XXXX-XXXX
```

<details>
<summary>コード例・解説</summary>

```ruby
# ユーザーから顧客情報を入力してもらうプログラム

# 名前の入力
print "名前を入力してください: "  # ユーザーに名前を入力するように促す
name = gets.chomp  # 入力された文字列から改行を取り除く

# 年齢の入力
print "年齢を入力してください: "  # ユーザーに年齢を入力するように促す
age = gets.to_i  # 入力を整数（数値）として取得する

# 住所の入力
print "住所を入力してください: "  # ユーザーに住所を入力するように促す
address = gets.chomp  # 入力された文字列から改行を取り除く

# 電話番号の入力
print "電話番号を入力してください: "  # ユーザーに電話番号を入力するように促す
phone = gets.chomp  # 入力された文字列から改行を取り除く

# 入力された情報をハッシュ（連想配列）に格納
customer_info = {
    name: name,      # キー : name に入力された名前を保存
    age: age,        # キー : age に入力された年齢を保存
    address: address,# キー : address に入力された住所を保存
    phone: phone     # キー : phone に入力された電話番号を保存
}

# 英語のキーを日本語に変換するためのハッシュ
key_translation = {
    name: "名前",
    age: "年齢",
    address: "住所",
    phone: "電話番号"
}

# 顧客情報を出力
puts "\n顧客情報:"
customer_info.each do |key, value|
    # 英語のキーを日本語に変換して表示
    puts "#{key_translation[key]}: #{value}"
end
```

1. **入力の取得**  
`gets.chomp` は入力値から改行コードを削除するために使います。`gets` だけだと入力の最後に改行が含まれるので、`chomp` を使ってそれを取り除きます。
`gets.to_i` は整数を入力として受け取るために使います。年齢を整数で処理するためです。

1. **ハッシュに格納**  
顧客情報は `customer_info` というハッシュに格納します。ハッシュを使うことで、名前や年齢、住所などをそれぞれのキーに対応させて管理できます。
例えば、`name: name` という形で、入力された名前をハッシュの `:name` キーに保存します。

1. **英語のキーを日本語に変換**  
ハッシュに用いられているキーは英語です。期待する出力例では項目名を日本語で表示しています。そのため、英語から日本語に翻訳するハッシュを作成します。
`customer_info`のキー名

1. **情報の表示**  
`each` メソッドを使って、ハッシュのキーと値を一つずつ取り出し、整形して表示します。

#### 発展

+ **バリデーション**  
ユーザーの入力が正しい形式かをチェックするバリデーションを追加すると、より実用的なプログラムになります。例えば、年齢が0以下でないことをチェックしたり、電話番号の形式が正しいかを確認したりします。

+ **複数顧客の登録**  
1人の顧客だけでなく、複数の顧客情報を管理できるようにすると、より実践的なシステムに近くなります。

</details>

<br>

---

---

### ビンゴカード作成プログラム

#### 要件
+ ビンゴカードは5×5のマスから構成され、各マスには1～75の数字がランダムに配置される
+ 中央のマス（3行3列）は「FREE」とし、他のマスには1～75の数字が重複しないように配置する
+ ビンゴカードを表示する

#### 期待する出力例(数字はランダム)
```ruby
ビンゴカード:
--------------------------
| 47 | 10 | 65 | 5  | 70 |
--------------------------
| 68 | 4  | 59 | 69 | 71 |
--------------------------
| 75 | 28 |FREE| 29 | 11 |
--------------------------
| 41 | 73 | 21 | 53 | 15 |
--------------------------
| 8  | 19 | 13 | 36 | 46 |
--------------------------
```

<details>
<summary>コード例・解説</summary>

```ruby
# ビンゴカードの作成プログラム

# 1～75の数字をランダムにシャッフルしてリストを作成
numbers = (1..75).to_a.shuffle

# 5×5のビンゴカード用の二次元配列を作成
bingo_card = Array.new(5) { Array.new(5) }

# 中央のマス（3行3列目）は「FREE」にする
bingo_card[2][2] = "FREE"

# ランダムな数字をビンゴカードに埋める
index = 0  # シャッフルした数字を取り出すためのインデックス

for i in 0..4  # 5行ループ
  for j in 0..4  # 5列ループ
    # すでに「FREE」が設定されているマスには数字を入れない
    if bingo_card[i][j] != "FREE"
      bingo_card[i][j] = numbers[index]  # ランダムな数字を代入
      index += 1  # 次の数字を使うためにインデックスを進める
    end
  end
end

# ビンゴカードを表示
puts "ビンゴカード:"
puts "-" * 26  # 1つ目の罫線の出力

bingo_card.each do |row|  # 1行ずつ取り出す
  row.each do |cell|  # 1つの行の各セルを取り出す
    print "|", cell.to_s.center(4)  # セルの中身を中央寄せで表示
  end
  puts "|"  # 行の最後に区切りを追加
  puts "-" * 26  # 罫線を追加
end

```

1. **数字のシャッフル**  
`numbers = (1..75).to_a.shuffle` で、1から75までの数字をシャッフルしてランダムに並べます。

1. **ビンゴカードの初期化**  
`Array.new(5) { Array.new(5) }` を使って、5×5の空のビンゴカードを作成します。

1. **中央マスの設定**  
`bingo_card[2][2] = "FREE"` で、中央のマスに「FREE」を設定します。

1. **ランダムな数字の配置**  
`index` という変数を使って、シャッフルした数字を順番に配置します。中央のマスは「FREE」なので、それ以外のマスに数字を配置します。

1. **ビンゴカードの表示**  
`puts "-" * 26` でビンゴカードを区切り線で整え、`print` を使って各セルの内容を表示します。`center(4)` でセル内の数字を中央寄せして見やすくします。

</details>

<br>

---

### コンソールRPG  

#### 要件  
- 勇者パーティとモンスターパーティが交互に攻撃を行い、どちらかのパーティが全滅したら戦闘終了する。  
- 勇者（プレイヤー）の名前は起動時にユーザーが入力できる。  
- 各キャラクターにはHP（体力）と攻撃力があり、攻撃を受けるとHPが減少する。  
- 攻撃時に、攻撃者の攻撃力分だけ敵のHPを減少させる。  
- HPが0になったキャラクターは行動できない。  
- ターンごとに現在のターン数と戦況を表示する。  
- 勇者パーティが勝てば「勇者パーティの勝利！」、負ければ「GAME OVER」と表示する。  
- 以下は各キャラクターの仕様である。  
    - **勇者（プレイヤー）**  
        - HP：30
        - 攻撃力：8
        - 通常攻撃を行う
    - **魔術師**  
        - HP：20
        - 攻撃力：6
        - 魔法攻撃（通常攻撃と同じ処理）
    - **オーク**  
        - HP：25
        - 攻撃力：7
    - **ゴブリン**  
        - HP：15
        - 攻撃力：5

#### 期待する出力例
+ **通常**
  ```sh
  勇者の名前を入力してください:
  勇者A

  === ターン 1 ===
  勇者A: HP=30 Attack=6
  魔術師: HP=20 Attack=8
  オーク: HP=30 Attack=8
  ゴブリン: HP=25 Attack=6

  勇者Aのターンです。
  1: 攻撃 2: 逃げる
  1
  勇者Aの攻撃！オークに6のダメージ！
  オークは死滅した！

  === ターン 2 ===
  勇者A: HP=30 Attack=6
  魔術師: HP=20 Attack=8
  ゴブリン: HP=25 Attack=6

  魔術師のターンです。
  魔術師の魔法攻撃！ゴブリンに7のダメージ！
  ゴブリンは死滅した！

  勇者パーティの勝利！
  ```

+ **逃げる**
  ```sh
  勇者の名前を入力してください:
  勇者A

  === ターン 1 ===
  勇者A: HP=30 Attack=6
  魔術師: HP=20 Attack=8
  オーク: HP=30 Attack=8
  ゴブリン: HP=25 Attack=6

  勇者Aのターンです。
  1: 攻撃 2: 逃げる
  2
  勇者Aは逃げた！
  GAME OVER
  ```

<details>
<summary>コード例・解説</summary>

```ruby
class Message
  # 各種メッセージを管理するクラス

  # ターン数表示
  def self.game_turn(turn)
    puts "\n=== ターン #{turn} ==="
  end

  # 操作メッセージ
  def self.action_select(hero)
    puts "#{hero.name}のターンです。"
    puts "1: 攻撃 2: 逃げる"
  end

  # 無効な選択肢が入力された際のメッセージを表示
  def self.invalid_choice
    puts "無効な選択肢です。再度選んでください。"
  end

  # 攻撃のメッセージを表示
  def self.attack(attacker, target, damage)
    puts "#{attacker.name}の攻撃！#{target.name}に#{damage}のダメージ！"
  end

  # 魔法攻撃のメッセージを表示
  def self.magic_attack(attacker, target, damage)
    puts "#{attacker.name}の魔法攻撃！#{target.name}に#{damage}のダメージ！"
  end

  # キャラクターが死亡したメッセージを表示
  def self.death(target)
    puts "#{target.name}は死滅した！"
  end

  # 勇者が逃げた際のメッセージを表示し、ゲームオーバーを宣言
  def self.escape(hero)
    puts "#{hero.name}は逃げた！"
    puts "GAME OVER"
  end

  # 勝敗結果を表示するメッセージ
  def self.winner(hero_alive)
    if hero_alive
      puts "勇者パーティの勝利！"
    else
      puts "GAME OVER"
    end
  end
end

class Character
  attr_accessor :name, :hp, :attack_power, :cpu

  # キャラクターの初期設定を行う
  def initialize(name, hp, attack_power, cpu = false)
    @name = name
    @hp = hp
    @attack_power = attack_power
    @cpu = cpu # CPU操作キャラクターかどうかを示すフラグ
  end

  # ダメージを受ける処理
  def take_damage(damage)
    @hp -= damage
    @hp = 0 if @hp < 0 # HPが0未満にならないよう調整
  end

  # 通常攻撃の処理
  def attack(target)
    # 攻撃力の範囲をランダムに決定(ステータスの攻撃力の±3)
    damage = rand(@attack_power - 3..@attack_power + 3)
    target.take_damage(damage)  # 対象キャラクターにダメージを与える
    Message.attack(self, target, damage) # 攻撃メッセージを表示
    Message.death(target) if target.hp == 0 # HPが0になったら死滅メッセージを表示
    damage
  end

  # 魔法攻撃の処理
  def magic_attack(target)
    # 魔法攻撃のダメージも通常攻撃と同様にランダムに決定
    damage = rand(@attack_power - 3..@attack_power + 3)
    target.take_damage(damage)  # 対象キャラクターにダメージを与える
    Message.magic_attack(self, target, damage) # 魔法攻撃メッセージを表示
    Message.death(target) if target.hp == 0 # HPが0になったら死滅メッセージを表示
    damage
  end

  # キャラクターのステータスを表示
  def status
    # HPが0なら死滅マーカーをつける
    dead_marker = @hp == 0 ? "✕" : ""
    "#{dead_marker}#{@name}: HP=#{@hp} Attack=#{@attack_power}"
  end

  # キャラクターが生存しているかを判定
  def alive?
    @hp > 0
  end
end

class Game
  # ゲームの初期設定を行う
  def initialize
    # プレイヤーに勇者の名前を入力させる
    puts "勇者の名前を入力してください:"
    hero_name = gets.chomp
    
    # キャラクターの作成
    @heroes = [
      Character.new(hero_name, 30, 6), # プレイヤーが操作する勇者
      Character.new('魔術師', 20, 8, true) # CPU操作の魔術師
    ]
    @monsters = [
      Character.new('オーク', 30, 8, true), # CPU操作のオーク
      Character.new('ゴブリン', 25, 6, true) # CPU操作のゴブリン
    ]
  end

  # ゲーム開始処理
  def start
    turn = 0
    while @heroes.any?(&:alive?) && @monsters.any?(&:alive?)
      turn += 1
      Message.game_turn(turn)
      show_status  # 現在のステータスを表示
      attack_hero_turn if @heroes.any?(&:alive?) # 勇者側のターン
      break if game_over? # ゲームオーバー判定
      attack_monster_turn if @monsters.any?(&:alive?) # モンスター側のターン
      break if game_over? # ゲームオーバー判定
    end

    Message.winner(@heroes.any?(&:alive?)) # 勝者のメッセージを表示
  end

  private

  # キャラクターのステータスを表示するメソッド
  def show_status
    # 勇者とモンスターそれぞれのステータスを表示
    @heroes.each { |hero| puts hero.status }
    @monsters.each { |monster| puts monster.status }
  end

  # 勇者パーティ側のターンを処理
  def attack_hero_turn
    @heroes.each do |hero|
      next unless hero.alive? # 生存しているキャラクターのターンのみ

      if hero.cpu
        # 勇者パーティのCPU操作キャラクターは自動で魔法攻撃を行う
        attack_target = @monsters.find(&:alive?)
        hero.magic_attack(attack_target) if attack_target
      else
        # プレイヤーが操作するキャラクターの行動選択
        loop do
          Message.action_select(hero)
          choice = gets.chomp.to_i

          case choice
          when 1
            # プレイヤーが攻撃を選択
            attack_target = @monsters.find(&:alive?)
            hero.attack(attack_target) if attack_target
            break
          when 2
            # プレイヤーが逃げるを選択
            Message.escape(hero)
            exit
          else
            Message.invalid_choice # 無効な選択肢
          end
        end
      end
    end
  end

  # モンスター側のターンを処理
  def attack_monster_turn
    @monsters.each do |monster|
      next unless monster.alive? # 生存しているモンスターのターンのみ

      # 勇者のいずれかをターゲットにして攻撃
      target = @heroes.find(&:alive?)
      monster.attack(target) if target
    end
  end

  # ゲームオーバー判定
  def game_over?
    # 勇者側またはモンスター側が全滅した場合
    !@heroes.any?(&:alive?) || !@monsters.any?(&:alive?)
  end
end

# ゲーム開始
game = Game.new
game.start
```
</summary>