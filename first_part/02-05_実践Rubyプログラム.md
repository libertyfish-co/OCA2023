# 2 実践Rubyプログラム

## 目次
+ [RPGバトルについて](#rpgバトルについて)

<br>

---

## RPGバトルについて

このテキストでは、Rubyを使ってシンプルなRPGバトルを実装します。ターン制バトルを作りながら、Rubyの基本的な構文や概念を復習します。また、本テキストのサンプルコードに登場する変数は自身がわかりやすいように適切に置き換えていただいて構いません。

### ゲームの目的

このゲームの目的は、プレイヤー（勇者）とコンピューター操作のモンスターが戦うターン制バトルを実装することです。プレイヤーは攻撃や魔法を使ってモンスターを倒し、勝利を目指します。

+ **完成イメージ（例）**

  ```sh
  ↓勇者の名前を入力してください↓

  ◆◆◆ モンスターが現れた！ ◆◆◆

  === ターン 1 ===
  ・【リバティ】 HP：30 こうげき力：6
  ・【魔法使い】 HP：20 こうげき力：8
  ・【オーク】 HP：30 こうげき力：8
  ・【ゴブリン】 HP：25 こうげき力：6

  リバティ のターンです。
  ↓行動を選択してください。↓
  【1】こうげき
  【2】逃げる
  リバティ のこうげき！
  →ゴブリン に 4 のダメージ！
  魔法使い は呪文をとなえた！
  →オーク に 9 のダメージ！
  オーク のこうげき！
  →リバティ に 10 のダメージ！
  ゴブリン のこうげき！
  →リバティ に 6 のダメージ！

  === ターン 2 ===
  ・【リバティ】 HP：14 こうげき力：6
  ・【魔法使い】 HP：20 こうげき力：8
  ・【オーク】 HP：21 こうげき力：8
  ・【ゴブリン】 HP：21 こうげき力：6

  リバティ のターンです。
  ↓行動を選択してください。↓
  【1】こうげき
  【2】逃げる
  リバティ のこうげき！
  →ゴブリン に 5 のダメージ！
  魔法使い は呪文をとなえた！
  →ゴブリン に 7 のダメージ！
  オーク のこうげき！
  →魔法使い に 11 のダメージ！
  ゴブリン のこうげき！
  →魔法使い に 5 のダメージ！

  ...

  === ターン 4 ===
  ・【リバティ】 HP：6 こうげき力：6
  ・【魔法使い】 HP：4 こうげき力：8
  ・【オーク】 HP：14 こうげき力：8
  ×【ゴブリン】 HP：0 こうげき力：6

  リバティ のターンです。
  ↓行動を選択してください。↓
  【1】こうげき
  【2】逃げる
  リバティ のこうげき！
  →オーク に 9 のダメージ！
  魔法使い は呪文をとなえた！
  →オーク に 10 のダメージ！
  →オーク は死滅した！
  ◆◆◆ 勇者パーティの勝利！ ◆◆◆
  ```

  <details>
  <summary>もっと見る</summary>

  ```sh
  ↓勇者の名前を入力してください↓

  ◆◆◆ モンスターが現れた！ ◆◆◆

  === ターン 1 ===
  ・【リバティ】 HP：30 こうげき力：6
  ・【魔法使い】 HP：20 こうげき力：8
  ・【オーク】 HP：30 こうげき力：8
  ・【ゴブリン】 HP：25 こうげき力：6

  リバティ のターンです。
  ↓行動を選択してください。↓
  【1】こうげき
  【2】逃げる
  リバティ のこうげき！
  →ゴブリン に 6 のダメージ！
  魔法使い は呪文をとなえた！
  →ゴブリン に 5 のダメージ！
  オーク のこうげき！
  →リバティ に 9 のダメージ！
  ゴブリン のこうげき！
  →魔法使い に 8 のダメージ！

  === ターン 2 ===
  ・【リバティ】 HP：21 こうげき力：6
  ・【魔法使い】 HP：12 こうげき力：8
  ・【オーク】 HP：30 こうげき力：8
  ・【ゴブリン】 HP：14 こうげき力：6

  リバティ のターンです。
  ↓行動を選択してください。↓
  【1】こうげき
  【2】逃げる
  リバティ のこうげき！
  →ゴブリン に 3 のダメージ！
  魔法使い は呪文をとなえた！
  →オーク に 10 のダメージ！
  オーク のこうげき！
  →魔法使い に 10 のダメージ！
  ゴブリン のこうげき！
  →リバティ に 7 のダメージ！

  ...

  === ターン 4 ===
  ・【リバティ】 HP：10 こうげき力：6
  ×【魔法使い】 HP：0 こうげき力：8
  ・【オーク】 HP：14 こうげき力：8
  ・【ゴブリン】 HP：4 こうげき力：6

  リバティ のターンです。
  ↓行動を選択してください。↓
  【1】こうげき
  【2】逃げる
  リバティ のこうげき！
  →オーク に 7 のダメージ！
  オーク のこうげき！
  →リバティ に 11 のダメージ！
  →リバティ は死滅した！
  ◆◆◆ GAME OVER ◆◆◆
  ```
  
  ```sh
  ↓勇者の名前を入力してください↓

  ◆◆◆ モンスターが現れた！ ◆◆◆

  === ターン 1 ===
  ・【リバティ】 HP：30 こうげき力：6
  ・【魔法使い】 HP：20 こうげき力：8
  ・【オーク】 HP：30 こうげき力：8
  ・【ゴブリン】 HP：25 こうげき力：6

  リバティ のターンです。
  ↓行動を選択してください。↓
  【1】こうげき
  【2】逃げる
  リバティ は逃げ出した！
  ◆◆◆ GAME OVER ◆◆◆
  ```

  </summary>

---

### プログラムの流れ
プログラミングをする際には、まずプログラムの流れを把握することが重要です。以下のフローチャートは、その流れを例として簡潔に示したものです。

<img src="images/実践Rubyプログラム/フロー.png" width="500px">

プログラムの流れを理解した上でコーディングを進めることは、非常に効果的です。流れを整理することで、よりスムーズにプログラミングを進めることができます。  

また、プログラムの構成を考えることも大切です。例えば、どのようなクラスを作成するか、どんなメソッドを用意するかなど、正解は一つではありません。このテキストではお手本のコードに沿っていきますが、自分なりに最適な設計を考えてみてもいいかもしれません。  

いよいよプログラミングに入っていきますが、いきなり大きなプログラムを作ることは非常に難しいです。全体のイメージを持ちながら、部分的に少しずつ組み立てて行きましょう。

---

## RPGバトルを作ろう

### ゲーム進行クラス作成

まず最低限動くプログラムを作っていきます。  
`rpg_battle.rb`ファイルを作成し、ゲームを進行するクラスを作りましょう。  
ひとまず勇者の名前を決めてもらいましょうか。

```rb
# ゲームを進行するクラス
class Game
  # ゲームの初期設定を行う
  def initialize
    puts "↓勇者の名前を入力してください↓"
    hero_nm = gets.chomp        # 入力受付

    puts "勇者の名前は#{hero_nm}です。"
  end
end

# ゲーム開始
Game.new
```
> chompメソッドは改行を消してくれるメソッドです。これをgetsに付け忘れると文字列が表示されるたびに改行が入ってしまうので注意しましょう。  

`initialize`はオブジェクトの生成時に1度だけ実行されるメソッドなので、初期設定としてユーザーから名前を受け取ります。  
`Game.new`でオブジェクトを生成して`initialize`を実行します。実行結果は以下のようになります。  

```sh
↓勇者の名前を入力してください↓
リバティ # ユーザーが入力
勇者の名前はリバティです。
```

無事に動きましたか？現段階では勇者の名前を決めただけです。他にもステータスなどの情報を持たせてあげたいですよね。  
そこで、キャラクター専門のクラスを作ってあげましょう。

---

### キャラクタークラス作成

`Character`クラスの`initialize`には、各キャラのステータスを割り当てるために、インスタンス変数を置きましょう。これによってオブジェクトごとに違う値をもたせる事ができます。  
今回は以下のステータスを想定して用意しています。

+ **キャラクター名**
+ **HP**
+ **こうげき力**
+ **こうげきタイプ**(通常:1 魔法:2)
+ **プレイヤーフラグ**(実際にユーザーが動きを操作するか否か)
+ **生存フラグ**(キャラクターがまだ生存しているか否か)  

```rb 
# キャラクタークラス
class Character
  # アクセサ
  attr_accessor :nm, :hp, :atk_pwr, :atk_type ,:plyr, :alive

  # キャラクターの初期設定を行う
  def initialize(nm, hp, atk_pwr, atk_type, plyr = false)
    @nm = nm              # キャラクター名
    @hp = hp              # HP
    @atk_pwr = atk_pwr    # こうげき力
    @atk_type = atk_type  # こうげきタイプ(通常:1 魔法:2)
    @plyr = plyr          # プレイヤーフラグ
    @alive = true         # 生存フラグ
  end
end
```

インスタンス変数にアクセスするためにはアクセサ(`attr_accessor`)を記述しておきます。  
また、`initialize`の実引数にそれぞれのインスタンス変数に対応する変数を入れています。  
>勇者(主人公)以外のキャラクターの操作を行うことは今回想定しないので、仮引数に`plyr`の値を入れなかった場合は`false`が自動的に入ります。  
>キャラクターは生成時には必ず生存しているので`alive`は常に`true`となり、引数を用意する必要はありません。直接`true`を入れておきます。  

これらが正しく記述できているか動かして確かめてみましょう。

先ほど作った`Game`クラスの`initialize`に`hero`というインスタンス変数を作り、`Character`クラスを呼び出し引数を渡してインスタンスを生成します。  
結果が次のようになるように呼び出してみましょう。  

```sh
↓勇者の名前を入力してください↓
リバティ # ユーザーが入力
キャラクター名：リバティ
HP：30
こうげき力：6
こうげきタイプ：1
プレイヤーフラグ：true
生存フラグ：true
```

<details>
<summary>コード例(クリックすると開きます)</summary>

```rb
# ゲームを進行するクラス
class Game
  # ゲームの初期設定を行う
  def initialize
    puts "↓勇者の名前を入力してください↓"
    hero_nm = gets.chomp  # 入力受付
    
    # キャラクターを作成
    @hero = Character.new(hero_nm, 30, 6, 1, true)  # (キャラクター名, HP, こうげき力, こうげきタイプ, プレイヤーフラグ) 
    
    # 正しくセットされたか確認
    puts "キャラクター名：#{@hero.nm}"
    puts "HP：#{@hero.hp}"
    puts "こうげき力：#{@hero.atk_pwr}"
    puts "こうげきタイプ：#{@hero.atk_type}"
    puts "プレイヤーフラグ：#{@hero.plyr}"
    puts "生存フラグ：#{@hero.alive}"
  end
end
```
</details>

インスタンス変数を通して呼び出すことができたら、同様に敵のキャラクターとしてオーク(`ork`)も作ってみましょう。

```sh
キャラクター名：オーク
HP：30
こうげき力：8
こうげきタイプ：1
プレイヤーフラグ：false
生存フラグ：true
```

<details>
<summary>コード例(クリックすると開きます)</summary>

```rb
  @hero = Character.new(hero_nm, 30, 6, 1, true)
  @ork = Character.new('オーク', 30, 8, 1)
```
</details>

うまくキャラクターの作成を行うことができましたね。  

<br>

---

### 定数クラス作成

先ほど作ったキャラクターのオブジェクトには、こうげきタイプを持たせています。
```rb
atk_type = 1  # こうげきタイプ(通常:1 魔法:2)
puts atk_type #=> 1
```
サンプルコードを見てみると「`1`」なら「通常こうげき」、「`2`」なら「魔法こうげき」とコメントを入れてある通り、基本的に値でタイプを割り当てていますね。「`通常こうげき`」といった文字列を変数に持たせることももちろん可能ですが、値の比較やコードの保守の観点から見るとあまり好ましくないので避けるべきです。  

もし、このコメントがなければどうなるでしょうか？  
```rb
atk_type = 1  # こうげきタイプ
puts atk_type #=> 1
```
数字だけを見ても一体何の数字なのかがわからなくなります。このようによくわからない数字のことを**マジックナンバー**と言います。

マジックナンバーを生み出さないために、極力定数にできるものは定数として宣言してあげましょう。  
以下のように定数クラスを作り、定数を宣言します。

```rb
# 定数クラス
class Constants
  ATK_TYPE_NORMAL = 1
end
```

`1`という数字の代わりに`ATK_TYPE_NORMAL`という定数が使えるようになりました。
これを呼び出してキャラクターのオブジェクトを作成してみます。

```rb
# 勇者の例
Character.new(hero_nm, 30, 6, Constants::ATK_TYPE_NORMAL, true)
```

結果は変わらず`1`を示します。

```sh
↓勇者の名前を入力してください↓
リバティ # ユーザーが入力
キャラクター名：リバティ
HP：30
こうげき力：6
こうげきタイプ：1
プレイヤーフラグ：true
生存フラグ：true
```

また、定数を使うことにより、コード全体で値を一元管理できるようになります。たとえば、通常こうげきは`1`だったけれど、やっぱり`3`にしたい場合、定義されている定数の値を`3`に変更するだけで、コード全体を修正せずにすみます。

<br>

---

### メソッドの活用

今後キャラを増やしていくことを見据えると、すべてを`initialize`に書くのは可読性の低下を招いてしまいます。
また、現時点では勇者とオークしかいないため敵と味方が明確ですが、増えていくと管理をするのが大変になります。  
これらを整理するために味方を生成するメソッド、敵を生成するメソッドを作ってみます。コードは以下のようになります。

```rb
# ゲームを進行するクラス
class Game
  # ゲームの初期設定を行う
  def initialize
    puts "↓勇者の名前を入力してください↓"
    hero_nm = gets.chomp  # 入力受付
    
    # キャラクターを作成
    @heroes = create_heroes(hero_nm)
    @mnstrs = create_mnstrs()

    # キャラクターが生成されていることを確認
    puts "\nキャラクター名：#{@heroes.nm}"
    puts "HP：#{@heroes.hp}"
    puts "こうげき力：#{@heroes.atk_pwr}"
    puts "こうげきタイプ：#{@heroes.atk_type}"
    puts "プレイヤーフラグ：#{@heroes.plyr}"
    puts "生存フラグ：#{@heroes.alive}"

    # キャラクターが生成されていることを確認
    puts "\nキャラクター名：#{@mnstrs.nm}"
    puts "HP：#{@mnstrs.hp}"
    puts "こうげき力：#{@mnstrs.atk_pwr}"
    puts "こうげきタイプ：#{@mnstrs.atk_type}"
    puts "プレイヤーフラグ：#{@mnstrs.plyr}"
    puts "生存フラグ：#{@mnstrs.alive}"
  end

  private

  # 勇者パーティの作成
  def create_heroes(hero_nm)
    Character.new(hero_nm, 30, 6, Constants::ATK_TYPE_NORMAL, true)  # プレイヤーが操作する勇者
  end

  # モンスターパーティの作成
  def create_mnstrs
    Character.new('オーク', 30, 8, Constants::ATK_TYPE_NORMAL)   # オーク(CPU)
  end
end
```

基本的にRubyのメソッドでは、`return`などのメソッドを抜ける処理が実行されない場合、最後に評価された式の値やオブジェクトが呼び出し元に返されます（明示的に`return`を記述することもできます）。そのため、`@heroes`には勇者パーティのキャラクター、`@mnstrs`には敵パーティのキャラクターのオブジェクトがそれぞれ入っています。  
実行すると以下のようになります。  

```rb
↓勇者の名前を入力してください↓
リバティ # ユーザーが入力

キャラクター名：リバティ
HP：30
こうげき力：6
こうげきタイプ：1
プレイヤーフラグ：true
生存フラグ：true

キャラクター名：オーク
HP：30
こうげき力：8
こうげきタイプ：1
プレイヤーフラグ：false
生存フラグ：true
```

>キャラクター作成を行うメソッドはどちらもクラス外から呼び出すことは無いので、`private`として定義しています。必ずしも`private`として定義する必要はありませんが、必要最低限の範囲からしか呼び出せないようにすることでバグが発生する可能性を未然に防ぐことができるため、非常に重要です。  






---


<button onclick="downloadImage()">ダウンロードボタン</button>

<script>
function downloadImage() {
    const imageUrl = "images/3-1-1.png";
    const a = document.createElement("a");
    a.href = imageUrl;
    a.download = "sample.png";  // ダウンロード時のファイル名
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}
</script>
