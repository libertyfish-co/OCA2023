# 2 実践Rubyプログラム

## 目次
+ [RPGバトルについて](#rpgバトルについて)

<br>

---

### ラウンドをループさせよう
前セクションでの動作テストが問題なかったら、`start`メソッド内の処理をループさせましょう。加えて、今が何ラウンド目なのかを表示させてみます。

```rb
# ゲーム開始処理
def start
  round = 0   # ラウンド数
  
  # 開始メッセージ
  puts "\n◆◆◆ モンスターが現れた！ ◆◆◆"
  
  loop do
    # ラウンド数
    round += 1
    puts "\n=== ラウンド #{round} ==="

    # ステータス表示
    show_stts(@heroes)  # 勇者パーティ表示
    show_stts(@mnstrs)  # モンスターパーティ表示

    # 勇者パーティのターン
    hero_turn()
    return if @esc_flg  # 逃げた場合は終了

    # モンスターのターン
    mnst_turn()
  end
end
```

勝敗はつきませんが、ゲームとして成り立つループが完成します。

<br>

---

### キャラクターを増やしてみよう
基本的な構造は出来上がってきたので、キャラクターを追加してみます。  
現在のパーティ作成メソッド(`create_heroes`、`create_mnstrs`)ではそれぞれ1人までしかキャラクターを定義できません。  
では、これ以上のメソッドを増やさず、複数のキャラクターのオブジェクトを作成して戻り値として返すにはどうしたらよいのでしょうか？少し考えてみましょう。

+ 勇者パーティに追加するキャラクター
  + 魔法使い
  + HP：20
  + こうげき力：8
  + 魔法こうげきを使用
+ モンスターパーティに追加するキャラクター
  + ゴブリン
  + HP：25
  + こうげき力：6
  + 通常こうげきを使用


```rb
# 現在のコード

# 勇者パーティの作成
def create_heroes(hero_nm)
  Character.new(hero_nm, 30, 6, Constants::ATK_TYPE_NORMAL, true)  # プレイヤーが操作する勇者
end

# モンスターパーティの作成
def create_mnstrs
  Character.new('オーク', 30, 8, Constants::ATK_TYPE_NORMAL)   # オーク(CPU)
end
```
>**ヒント**：オブジェクトは配列に格納させることができます。

<details>
<summary>コード例</summary>

```rb
# 勇者パーティの作成
def create_heroes(hero_nm)
  [
    Character.new(hero_nm, 30, 6, Constants::ATK_TYPE_NORMAL, true),  # プレイヤーが操作する勇者
    Character.new('魔法使い', 20, 6, Constants::ATK_TYPE_MAGIC)        # 魔法使い(CPU)
  ] 
end

# モンスターパーティの作成
def create_mnstrs
  [
    Character.new('オーク', 30, 8, Constants::ATK_TYPE_NORMAL),    # オーク(CPU)
    Character.new('ゴブリン', 25, 6, Constants::ATK_TYPE_NORMAL)   # ゴブリン(CPU)
  ]
end
```

このように、配列の中にオブジェクトを格納することができました。
</details>

配列の中にオブジェクトを格納したので、それぞれ一部コードの改修が必要になります。  
以下はその例です。

```rb
# ステータス表示
# 変更前
def show_stts(chrct)
    puts "・【#{chrct.nm}】 HP：#{chrct.hp} こうげき力：#{chrct.atk_pwr}"
end

# 変更後
def show_stts(prty)
    prty.each { |chrct| puts "・【#{chrct.nm}】 HP：#{chrct.hp} こうげき力：#{chrct.atk_pwr}"}
end
```

`each`メソッドでオブジェクトを立て続けに呼び出し、同様の処理をしています。  

---

#### パーティ全員で行動しよう  

次にパーティの全員が行動できるように書き換えていきます。  

>**ヒント**：`@heroes.each do |hero|`~`end`で囲ってみます。`hero`が各オブジェクトになります。  
>死滅してしまったキャラクターは行動してはいけないため、`next unless hero.alive`でスキップさせることができます
```rb
# 勇者パーティのターン
def hero_turn
  @heroes.each do |hero|    #　@heroesの各オブジェクトを呼び出す
    next unless hero.alive    # aliveがfalseなら以下の処理を行わない
    loop do
      puts "\n↓行動を選択してください↓"
      puts "【#{Constants::CHOICE_ATK}】こうげき"
      puts "【#{Constants::CHOICE_ESC}】逃げる"
      choice = gets.to_i  # 行動の入力を整数で受け付ける
      
      # 略
      
    end
  end
end
```

これで各キャラクターのオブジェクトごとに同じ処理が走るようになりましたが、このままではこうげきする際などのメソッドの引数が適切ではありません。そちらも合わせて変えていきます。
`@heroes`を渡しているところは各キャラのオブジェクトを渡せばいいので、`hero`に書き換えます。

```rb
# 勇者パーティのターン
def hero_turn
  @heroes.each do |hero|    # 各キャラ呼び出し
    next unless hero.alive    # 死滅はスキップ
    loop do
      puts "\n↓行動を選択してください↓"
      puts "【#{Constants::CHOICE_ATK}】こうげき"
      puts "【#{Constants::CHOICE_ESC}】逃げる"
      choice = gets.to_i  # 行動の入力を整数で受け付ける
      
      # 行動
      case choice
      when Constants::CHOICE_ATK
        # こうげき
        atk(hero, @mnstrs) # こうげき処理
        break                 # ループを抜ける
      when Constants::CHOICE_ESC
        # 逃げる
        esc(hero)   # 逃げる処理
        return  # メソッドを抜ける
      else
        # 無効な選択
        puts "無効な選択肢です"
      end
    end
  end
end
```

そしてここで気づいた人もいるかも知れませんが、`@mnstrs`からどうやってこうげき対象を絞るのでしょうか？  
敵のオブジェクトから選択式にするのもよいですが、せっかくなので相手をランダムにするコードを書いてみましょう。  
また、ランダムに選んだ相手が死滅していた場合にはこうげきすることができないので、その点も工夫してみましょう。

```rb
# 略

# 行動
case choice
when Constants::CHOICE_ATK
  # こうげき

  ###### ??????? #####

  break   # ループを抜ける
when Constants::CHOICE_ESC
  # 逃げる
  esc(hero)   # 逃げる処理
  return  # メソッドを抜ける
else
  # 無効な選択
  puts "無効な選択肢です"
end
```

>**ヒント**:ランダムに選ぶメソッドはrandだけではありません。どうやって一つに絞るのがよいか、考えてみましょう。

<details>
<summary>コード例・解説</summary>

```rb
# 略

# 行動
case choice
when Constants::CHOICE_ATK
  # こうげき
  atk_trgt = @mnstrs.select(&:alive).sample   # 対象を絞る
  atk(hero, atk_trgt) if atk_trgt             # こうげき処理
  break   # ループを抜ける
when Constants::CHOICE_ESC
  # 逃げる
  esc(hero)   # 逃げる処理
  return  # メソッドを抜ける
else
  # 無効な選択
  puts "無効な選択肢です"
end
```

+ `atk_trgt = @mnstrs.select(&:alive).sample`  
  `alive`が`true`になっているオブジェクトを`select`で絞り込みます。その後、`sample`でこうげき対象となるオブジェクトをランダムに1つ取り出します。  
+ `atk(hero, atk_trgt) if atk_trgt`  
  もし生存キャラクターがいなかった場合、`atk_trgt`は`nil`になるため、そのまま`atk`メソッドの引数に渡して実行するとエラーが発生します。そこで、`atk_trgt`が存在する(`true`)のときのみ実行することでエラーを防ぎます。  
</details>

うまく動いたら、モンスターパーティの行動メソッドも同様に書き換えておきましょう。

<details>
<summary>コード例</summary>

```rb
# 略

# モンスターのターン
def mnst_turn
  @mnstrs.each do |mnst|
    next unless mnst.alive                      # 死滅はスキップ
    atk_trgt = @heroes.select(&:alive).sample   # 対象を絞る
    atk(mnst, atk_trgt) if atk_trgt             # こうげき処理
  end
end
```
</details>

---

