# 2 実践Rubyプログラム

## 目次
+ [RPGバトルについて](#rpgバトルについて)

<br>

---

### ラウンドをループさせよう
前セクションでの動作テストが問題なかったら、`start`メソッド内の処理をループさせましょう。加えて、今が何ラウンド目なのかを表示させてみます。

```rb
# 例

# ゲーム開始処理
def start
  round = 0   # ラウンド数
  
  # 開始メッセージ
  puts "\n◆◆◆ モンスターが現れた！ ◆◆◆"
  
  loop do
    # ラウンド数
    round += 1
    puts "\n=== ラウンド #{round} ==="

    # ステータス表示
    show_status(@heroes)    # 勇者パーティ表示
    show_status(@monsters)  # モンスターパーティ表示

    # 勇者パーティのターン
    heroes_status()
    return if @escape_flg  # 逃げた場合は終了

    # モンスターのターン
    monsters_turn()
  end
end
```

勝敗はつきませんが、ゲームとして成り立つループが完成します。

<br>

---

### キャラクターを増やしてみよう
基本的な構造は出来上がってきたので、キャラクターを追加してみます。  
現在のパーティ作成メソッド(`create_heroes`、`create_monsters`)ではそれぞれ1人までしかキャラクターを定義できません。  
では、これ以上のメソッドを増やさず、複数のキャラクターのオブジェクトを作成して戻り値として返すにはどうしたらよいのでしょうか？少し考えてみましょう。

+ 勇者パーティに追加するキャラクター
  + 魔法使い
  + HP：20
  + こうげき力：8
  + 魔法こうげきを使用
+ モンスターパーティに追加するキャラクター
  + ゴブリン
  + HP：25
  + こうげき力：6
  + 通常こうげきを使用


```rb
# 現在のコード

# 勇者パーティの作成
def create_heroes(hero_name)
  Character.new(hero_name, 30, 6, Constants::ATTACK_TYPE_NORMAL, true)  # プレイヤーが操作する勇者
end

# モンスターパーティの作成
def create_monsters
  Character.new('オーク', 30, 8, Constants::ATTACK_TYPE_NORMAL)   # オーク(CPU)
end
```
>**ヒント**：オブジェクトは配列に格納させることができます。

<details>
<summary>コード例</summary>

```rb
# 勇者パーティの作成
def create_heroes(hero_name)
  [
    Character.new(hero_name, 30, 6, Constants::ATTACK_TYPE_NORMAL, true),  # プレイヤーが操作する勇者
    Character.new('魔法使い', 20, 8, Constants::ATTACK_TYPE_MAGIC)          # 魔法使い(CPU)
  ] 
end

# モンスターパーティの作成
def create_monsters
  [
    Character.new('オーク', 30, 8, Constants::ATTACK_TYPE_NORMAL),    # オーク(CPU)
    Character.new('ゴブリン', 25, 6, Constants::ATTACK_TYPE_NORMAL)   # ゴブリン(CPU)
  ]
end
```

このように、配列の中にオブジェクトを格納することができました。
</details>

配列の中にオブジェクトを格納したので、一部コードの改修が必要になります。  
以下はその例です。

```rb
# 変更前
show_status(@heroes)

# 変更後の例1
@heroes.each { |character| show_status(character) } 

# 変更後の例2
for character in @heroes
  show_status(character)
end
```

`each`メソッドでオブジェクトを立て続けに呼び出し、同様の処理をしています。  
適切にオブジェクトを渡せているか、ほかにも改修が必要な場所はないか、コード全体を見返して変更を適用してみましょう。

---

#### パーティ全員で行動しよう  

次にパーティの全員が行動できるように書き換えていきます。  

>**ヒント**：`@heroes.each do |character|`~`end`で囲ってみます。`character`が各オブジェクトになります。  
>死滅してしまったキャラクターは行動してはいけないため、`next unless character.is_alive`でスキップさせることができます。
```rb
# 勇者パーティのターン
def heroes_turn
  @heroes.each do |character|    #　@heroesの各オブジェクトを呼び出す
    next unless character.is_alive    # is_aliveがfalseなら以下の処理を行わない
    loop do
      puts "\n↓行動を選択してください↓"
      puts "【#{Constants::ACTION_ATTACK}】こうげき"
      puts "【#{Constants::ACTION_ESCAPE}】逃げる"
      choice = gets.to_i  # 行動の入力を整数で受け付ける
      
      # 略
      
    end
  end
end
```

行動を選択するのは勇者だけでいいので、`is_player`が`true`の場合のみ行動選択を表示させましょう。

```rb
# 勇者パーティのターン
def heroes_turn
  @heroes.each do |character|    #　@heroesの各オブジェクトを呼び出す
    next unless character.is_alive    # is_aliveがfalseなら以下の処理を行わない
    loop do
      # 行動選択
      if character.is_player
        # プレイヤー（勇者）のとき
        puts "\n↓行動を選択してください↓"
        puts "【#{Constants::ACTION_ATTACK}】こうげき"
        puts "【#{Constants::ACTION_ESCAPE}】逃げる"
        
        choice = gets.to_i  # 行動の入力を整数で受け付ける
      else
        # それ以外のとき
        choice = Constants::ACTION_ATTACK # デフォルトの選択
      end

      # 略
    end
  end
end
```

これで各キャラクターのオブジェクトごとに処理が走るようになりましたが、このままではこうげきする際などのメソッドの引数が適切ではありません(`Character`クラスのオブジェクトではなく配列が丸ごと渡されるためエラーが発生します)。そちらも合わせて変えていきます。
`@heroes`を渡しているところは各キャラのオブジェクトを渡せばいいので、`character`に書き換えます。

```rb
# 勇者パーティのターン
def heroes_turn
  @heroes.each do |character|    # 各キャラ呼び出し
    next unless character.is_alive    # 死滅はスキップ
    loop do
      puts "\n↓行動を選択してください↓"
      puts "【#{Constants::ACTION_ATTACK}】こうげき"
      puts "【#{Constants::ACTION_ESCAPE}】逃げる"
      choice = gets.to_i  # 行動の入力を整数で受け付ける
      
      # 行動
      case choice
      when Constants::ACTION_ATTACK
        # こうげき
        execute_attack(character, @monsters) # こうげき処理
        break   # ループを抜ける
      when Constants::ACTION_ESCAPE
        # 逃げる
        execute_escape(character)   # 逃げる処理
        return  # メソッドを抜ける
      else
        # 無効な選択
        puts "無効な選択肢です"
      end
    end
  end
end
```

そしてここで気づいた人もいるかも知れませんが、`@monsters`からどうやってこうげき対象を絞るのでしょうか？  
敵のオブジェクトから選択式にするのもよいですが、せっかくなので相手をランダムにするコードを書いてみましょう。  
また、ランダムに選んだ相手が死滅していた場合にはこうげきすることができないので、その点も工夫してみましょう。

```rb
# 略

# 行動
case choice
when Constants::ACTION_ATTACK
  # こうげき

  ###### ??????? #####

  break   # ループを抜ける
when Constants::ACTION_ESCAPE
  # 逃げる
  execute_escape(character)   # 逃げる処理
  return  # メソッドを抜ける
else
  # 無効な選択
  puts "無効な選択肢です"
end
```

>**ヒント**:ランダムに選ぶメソッドはrandだけではありません。どうやって一つに絞るのがよいか、考えてみましょう。

<details>
<summary>コード例・解説</summary>

```rb
# 例1

# 略

# 行動
case choice
when Constants::ACTION_ATTACK
  # こうげき
  # 生きているモンスターを選ぶ
  target_monster = nil
  @monsters.each do |monster|
    if monster.is_alive
      target_monster = monster
      break  # 生きているモンスターが見つかったらループを抜ける
    end
  end

  if target_monster
    execute_attack(character, target_monster)  # 攻撃処理を実行
  end

  break   # ループを抜ける
when Constants::ACTION_ESCAPE
  # 逃げる
  execute_escape(character)   # 逃げる処理
  return                      # メソッドを抜ける
else
  # 無効な選択
  puts "無効な選択肢です。再度選択してください。"
end
```

```rb
# 例2

# 略

# 行動
case choice
when Constants::ACTION_ATTACK
  # こうげき
  target_monster = @monsters.select(&:is_alive).sample        # 対象を絞る
  execute_attack(character, target_monster) if target_monster # こうげき処理
  break   # ループを抜ける
when Constants::ACTION_ESCAPE
  # 逃げる
  execute_escape(character)   # 逃げる処理
  return  # メソッドを抜ける
else
  # 無効な選択
  puts "無効な選択肢です。再度選択してください。"
end
```

+ `target_monster = @monsters.select(&:is_alive).sample`  
  `alive`が`true`になっているオブジェクトを`select`で絞り込みます。その後、`sample`でこうげき対象となるオブジェクトをランダムに1つ取り出します。  
+ `execute_attack(character, target_monster) if target_monster`  
  もし生存キャラクターがいなかった場合、`target_monster`は`nil`になるため、そのまま`execute_attack`メソッドの引数に渡して実行するとエラーが発生します。そこで、`target_monster`が存在する(`true`)のときのみ実行することでエラーを防ぎます。  
</details>

うまく動いたら、モンスターパーティの行動メソッドも同様に書き換えておきましょう。

<details>
<summary>コード例</summary>

```rb
# 例1

# 略

# モンスターのターン
def monsters_turn
  @monsters.each do |monster|
    # 生きているキャラクターを選ぶ
    target_character = nil
    @heroes.each do |character|
      if character.is_alive
        target_character = character
        break  # 生きているキャラクターが見つかったらループを抜ける
      end
    end

    if target_character
      execute_attack(monster, target_character)  # 攻撃処理を実行
    end
  end
end
```

```rb
# 例2

# 略

# モンスターのターン
def monsters_turn
  @monsters.each do |monster|
    next unless monster.is_alive                                    # 死滅はスキップ
    target_character = @heroes.select(&:is_alive).sample            # 対象を絞る
    execute_attack(monster, target_character) if target_character   # こうげき処理
  end
end
```
</details>

---

### 勝敗をつけよう
勝ち負けの判定をつけます。HPの変動が発生した直後に、全滅したパーティがあるかどうか調べます。

#### 全滅チェックメソッドを作ろう

まずは指定されたパーティが全滅しているかどうか確かめるメソッド`party_destroyed?`を作りましょう。全滅した場合は`true`を返します。

```rb
# 例1

# パーティの全滅チェック
def party_destroyed?(party)
  # パーティのすべてのメンバーが生きているかを確認
  is_all_dead = true  # すべてが死んでいると仮定

  # パーティの各メンバーをチェック
  party.each do |member|
    if member.is_alive      # メンバーが生きていれば
      is_all_dead = false   # 死んでいないメンバーがいるので、全滅ではない
      break                 # 一度でも生きているメンバーが見つかればチェックを終了
    end
  end

  return is_all_dead  # すべてのメンバーが死んでいればtrue、それ以外はfalse
end
```

```rb
# 例2 1行で書いた場合

# パーティの全滅チェック
def party_destroyed?(party)
  party.none?(&:is_alive)  # 全滅ならtrue
end
```

これで、`party`に各パーティを入れると全滅チェックが走るようになりました。

---

#### 全滅チェックメソッドを呼び出そう

`start`メソッド内で、HPが変動するタイミングで全滅チェックをします。`true`のときにループを中断(`break`)することで、ゲームを終わらせる事ができます。

```rb
# ゲーム開始処理
def start
  round = 0   # ラウンド数
  
  # 開始メッセージ
  puts "\n◆◆◆ モンスターが現れた！ ◆◆◆"
  
  loop do
    # ラウンド数
    round += 1
    puts "\n=== ラウンド #{round} ==="

    # ステータス表示
    @heroes.each { |character| show_status(character) }    # 勇者パーティ表示
    @monsters.each { |character| show_status(character) }  # モンスターパーティ表示

    # 勇者パーティのターン
    heroes_turn()

    # 逃げた場合はメソッドを抜ける
    return if @escape_flg  

    # どちらかが全滅していたらループを抜ける
    break if party_destroyed?(@heroes) || party_destroyed?(@monsters)

    # モンスターのターン
    monsters_turn()

    # どちらかが全滅していたらループを抜ける
    break if party_destroyed?(@heroes) || party_destroyed?(@monsters)
  end
end
```

---

#### 勝敗判定

ループを抜けた後に勝敗判定をさせて、メッセージを表示させましょう。

```sh
# 勝った場合の例
勇者パーティの勝利！

# 負けた場合の例
勇者たちは力尽きてしまった！
◆◆◆   GAME OVER   ◆◆◆

# 逃げた場合の例
◆◆◆   GAME OVER   ◆◆◆
```

```rb
# ゲーム開始処理
def start
  round = 0   # ラウンド数
  
  # 開始メッセージ
  puts "\n◆◆◆ モンスターが現れた！ ◆◆◆"
  
  loop do
    # ラウンド数
    round += 1
    puts "\n=== ラウンド #{round} ==="

    # ステータス表示
    @heroes.each { |character| show_status(character) }    # 勇者パーティ表示
    @monsters.each { |character| show_status(character) }  # モンスターパーティ表示

    # 勇者パーティのターン
    heroes_turn()

    # 逃げた場合はメソッドを抜ける
    return if @escape_flg  

    # どちらかが全滅していたらループを抜ける
    break if party_destroyed?(@heroes) || party_destroyed?(@monsters)

    # モンスターのターン
    monsters_turn()

    # どちらかが全滅していたらループを抜ける
    break if party_destroyed?(@heroes) || party_destroyed?(@monsters)
  end

  ##### ここに勝敗判定 #####

end
```

<details>
<summary>コード例</summary>

```rb
# 例
if party_destroyed?(@monsters)
  puts "勇者パーティの勝利！"
  return
elsif party_destroyed?(@heroes)
  puts "勇者たちは力尽きてしまった！"
end

puts "◆◆◆ GAME OVER ◆◆◆"
```
</details>

---

### 完成した動きを確認しよう

ここまで正しくコーディングできていれば、実行結果は次のようになります。  
もしうまく動かない場合は自分のコードと見直して修正してみましょう。

```sh
# 勝利パターン
↓勇者の名前を入力してください↓
リバティ # ユーザーが入力

◆◆◆ モンスターが現れた！ ◆◆◆

=== ラウンド 1 ===
・【リバティ】 HP：30 こうげき力：6
・【魔法使い】 HP：20 こうげき力：8
・【オーク】 HP：30 こうげき力：8
・【ゴブリン】 HP：25 こうげき力：6

↓行動を選択してください↓
【1】こうげき
【2】逃げる
1 # ユーザーが入力
リバティのこうげき！
オーク に 7 のダメージ！
魔法使いのこうげき！
ゴブリン に 11 のダメージ！
オークのこうげき！
魔法使い に 5 のダメージ！
ゴブリンのこうげき！
リバティ に 3 のダメージ！

=== ラウンド 2 ===
・【リバティ】 HP：27 こうげき力：6
・【魔法使い】 HP：15 こうげき力：8
・【オーク】 HP：23 こうげき力：8
・【ゴブリン】 HP：14 こうげき力：6

↓行動を選択してください↓
【1】こうげき
【2】逃げる
1 # ユーザーが入力
リバティのこうげき！
オーク に 7 のダメージ！
魔法使いのこうげき！
ゴブリン に 8 のダメージ！
オークのこうげき！
リバティ に 8 のダメージ！
ゴブリンのこうげき！
リバティ に 3 のダメージ！

=== ラウンド 3 ===
・【リバティ】 HP：16 こうげき力：6
・【魔法使い】 HP：15 こうげき力：8
・【オーク】 HP：16 こうげき力：8
・【ゴブリン】 HP：6 こうげき力：6

↓行動を選択してください↓
【1】こうげき
【2】逃げる
1 # ユーザーが入力
リバティのこうげき！
オーク に 6 のダメージ！
魔法使いのこうげき！
オーク に 8 のダメージ！
オークのこうげき！
魔法使い に 5 のダメージ！
ゴブリンのこうげき！
魔法使い に 6 のダメージ！

=== ラウンド 4 ===
・【リバティ】 HP：16 こうげき力：6
・【魔法使い】 HP：4 こうげき力：8
・【オーク】 HP：2 こうげき力：8
・【ゴブリン】 HP：6 こうげき力：6

↓行動を選択してください↓
【1】こうげき
【2】逃げる
1 # ユーザーが入力
リバティのこうげき！
ゴブリン に 7 のダメージ！
ゴブリン は死滅した！
魔法使いのこうげき！
オーク に 5 のダメージ！
オーク は死滅した！
勇者パーティの勝利！
```

```sh
# 敗北パターン
↓勇者の名前を入力してください↓
リバティ # ユーザーが入力

◆◆◆ モンスターが現れた！ ◆◆◆

=== ラウンド 1 ===
・【リバティ】 HP：30 こうげき力：6
・【魔法使い】 HP：20 こうげき力：8
・【オーク】 HP：30 こうげき力：8
・【ゴブリン】 HP：25 こうげき力：6

↓行動を選択してください↓
【1】こうげき
【2】逃げる
1 # ユーザーが入力
リバティのこうげき！
ゴブリン に 3 のダメージ！
魔法使いのこうげき！
オーク に 8 のダメージ！
オークのこうげき！
魔法使い に 7 のダメージ！
ゴブリンのこうげき！
魔法使い に 5 のダメージ！

=== ラウンド 2 ===
・【リバティ】 HP：30 こうげき力：6
・【魔法使い】 HP：8 こうげき力：8
・【オーク】 HP：22 こうげき力：8
・【ゴブリン】 HP：22 こうげき力：6

↓行動を選択してください↓
【1】こうげき
【2】逃げる
1 # ユーザーが入力
リバティのこうげき！
ゴブリン に 6 のダメージ！
魔法使いのこうげき！
ゴブリン に 10 のダメージ！
オークのこうげき！
魔法使い に 9 のダメージ！
魔法使い は死滅した！
ゴブリンのこうげき！
リバティ に 7 のダメージ！

=== ラウンド 3 ===
・【リバティ】 HP：23 こうげき力：6
・【魔法使い】 HP：0 こうげき力：8
・【オーク】 HP：22 こうげき力：8
・【ゴブリン】 HP：6 こうげき力：6

↓行動を選択してください↓
【1】こうげき
【2】逃げる
1 # ユーザーが入力
リバティのこうげき！
オーク に 7 のダメージ！
オークのこうげき！
リバティ に 10 のダメージ！
ゴブリンのこうげき！
リバティ に 7 のダメージ！

=== ラウンド 4 ===
・【リバティ】 HP：6 こうげき力：6
・【魔法使い】 HP：0 こうげき力：8
・【オーク】 HP：15 こうげき力：8
・【ゴブリン】 HP：6 こうげき力：6

↓行動を選択してください↓
【1】こうげき
【2】逃げる
1 # ユーザーが入力
リバティのこうげき！
ゴブリン に 7 のダメージ！
ゴブリン は死滅した！
オークのこうげき！
リバティ に 7 のダメージ！
リバティ は死滅した！
勇者たちは力尽きてしまった！
◆◆◆ GAME OVER ◆◆◆
```

```sh
# 逃げるパターン
↓勇者の名前を入力してください↓
リバティ # ユーザーが入力
◆◆◆ モンスターが現れた！ ◆◆◆

=== ラウンド 1 ===
・【リバティ】 HP：30 こうげき力：6
・【魔法使い】 HP：20 こうげき力：8
・【オーク】 HP：30 こうげき力：8
・【ゴブリン】 HP：25 こうげき力：6

↓行動を選択してください↓
【1】こうげき
【2】逃げる
リバティは逃げ出した！
◆◆◆ GAME OVER ◆◆◆
```

<details>
<summary>参考コード</summary>

```rb
# 定数管理クラス
class Constants
  # ステータス
  HP_MIN = 0           # HP最小値
  ATTACK_VARIANCE = 3  # こうげき力のブレ幅

  # 行動選択
  ACTION_ATTACK = 1  # こうげき
  ACTION_ESCAPE = 2  # 逃げる

  # こうげきタイプ
  ATTACK_TYPE_NORMAL = 1  # 通常
  ATTACK_TYPE_MAGIC = 2   # 魔法こうげき
end

# キャラクタークラス
class Character
  # アクセサ
  attr_accessor :name, :hp, :attack_damage, :attack_type, :is_player, :is_alive

  # キャラクターの初期設定を行う
  def initialize(name, hp, attack_damage, attack_type, is_player = false)
    @name = name                    # キャラクター名
    @hp = hp                        # HP
    @attack_damage = attack_damage  # こうげき力
    @attack_type = attack_type      # こうげきタイプ
    @is_player = is_player          # プレイヤーフラグ
    @is_alive = true                # 生存フラグ
  end

  # ダメージ計算処理
  def calculate_damage
    # ランダムダメージ(こうげき力±振れ幅)
    rand(@attack_damage - Constants::ATTACK_VARIANCE..@attack_damage + Constants::ATTACK_VARIANCE)
  end

  # ダメージ反映処理
  def receive_damage(damage)
    @hp -= damage  # ダメージ処理

    # 死滅処理
    if @hp <= Constants::HP_MIN
      @hp = Constants::HP_MIN   # HPが0未満にならないよう調整 
      @is_alive = false         # 生存フラグを下ろす
    end
  end
end

# ゲームを進行するクラス
class Game
  # ゲームの初期設定を行う
  def initialize
    @escape_flg = false  # 逃げるフラグ

    puts "↓勇者の名前を入力してください↓"
    hero_name = gets.chomp  # 入力受付

    # キャラクターを作成
    @heroes = create_heroes(hero_name)
    @monsters = create_monsters()
  end

  # ゲーム開始処理
  def start
    round = 0   # ラウンド数

    # 開始メッセージ
    puts "\n◆◆◆ モンスターが現れた！ ◆◆◆"

    loop do
      # ラウンド数
      round += 1
      puts "\n=== ラウンド #{round} ==="

      # ステータス表示
      @heroes.each { |character| show_status(character) }    # 勇者パーティ表示
      @monsters.each { |character| show_status(character) }  # モンスターパーティ表示

      # 勇者パーティのターン
      heroes_turn()

      # 逃げた場合
      break if @escape_flg  

      # どちらかが全滅していたらループを抜ける
      break if party_destroyed?(@heroes) || party_destroyed?(@monsters)

      # モンスターのターン
      monsters_turn()

      # どちらかが全滅していたらループを抜ける
      break if party_destroyed?(@heroes) || party_destroyed?(@monsters)
    end

    if party_destroyed?(@monsters)
      puts "勇者パーティの勝利！"
      return
    elsif party_destroyed?(@heroes)
      puts "勇者たちは力尽きてしまった！"
    end

    puts "◆◆◆ GAME OVER ◆◆◆"
  end

  private

  # 勇者パーティの作成
  def create_heroes(hero_name)
    [
      Character.new(hero_name, 30, 6, Constants::ATTACK_TYPE_NORMAL, true),  # プレイヤーが操作する勇者
      Character.new('魔法使い', 20, 8, Constants::ATTACK_TYPE_MAGIC)          # 魔法使い(CPU)
    ]
  end

  # モンスターパーティの作成
  def create_monsters
    [
      Character.new('オーク', 30, 8, Constants::ATTACK_TYPE_NORMAL),    # オーク(CPU)
      Character.new('ゴブリン', 25, 6, Constants::ATTACK_TYPE_NORMAL)   # ゴブリン(CPU)
    ]
  end

  # こうげき共通
  def execute_attack(attacker, defender)  # (行動をするキャラクター, こうげき対象)
    # こうげきメッセージ
    puts "#{attacker.name}のこうげき！"

    # ダメージ処理
    damage = attacker.calculate_damage()  # ダメージ計算
    defender.receive_damage(damage)       # ダメージ反映

    puts "#{defender.name} に #{damage} のダメージ！"  # ダメージ処理

    puts "#{defender.name} は死滅した！" unless defender.is_alive # 死滅メッセージ
  end

  # 逃げる
  def execute_escape(character)
    puts "#{character.name}は逃げ出した！"  
    @escape_flg = true # 逃げるフラグを立てる
  end

  # ステータス表示
  def show_status(character)
    puts "・【#{character.name}】 HP：#{character.hp} こうげき力：#{character.attack_damage}"
  end

  # 勇者パーティのターン
  def heroes_turn
    @heroes.each do |character|    #　@heroesの各オブジェクトを呼び出す
      next unless character.is_alive    # is_aliveがfalseなら以下の処理を行わない
      loop do
        # 行動選択
        if character.is_player
          # プレイヤー（勇者）のとき
          puts "\n↓行動を選択してください↓"
          puts "【#{Constants::ACTION_ATTACK}】こうげき"
          puts "【#{Constants::ACTION_ESCAPE}】逃げる"
          
          choice = gets.to_i  # 行動の入力を整数で受け付ける
        else
          # それ以外のとき
          choice = Constants::ACTION_ATTACK # デフォルトの選択
        end

        # 行動
        case choice
        when Constants::ACTION_ATTACK
          # こうげき
          target_character = @monsters.select(&:is_alive).sample            # 対象を絞る
          execute_attack(character, target_character) if target_character   # こうげき処理
          break   # ループを抜ける
        when Constants::ACTION_ESCAPE
          # 逃げる
          execute_escape(character)   # 逃げる処理
          return  # メソッドを抜ける
        else
          # 無効な選択
          puts "無効な選択肢です"
        end
      end
    end
  end

  # モンスターのターン
  def monsters_turn
    @monsters.each do |monster|
      next unless monster.is_alive
      target_character = @heroes.select(&:is_alive).sample          # 対象を絞る
      execute_attack(monster, target_character) if target_character # (行動をするキャラクター, こうげき対象)
    end
  end

  # パーティの全滅チェック
  def party_destroyed?(party)
    party.none?(&:is_alive)  # 全滅ならtrue
  end
end

# ゲーム開始
game = Game.new
game.start()
```